{"version":3,"sources":["type/schema.js"],"names":[],"mappings":"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","file":"type/schema.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport {\n  GraphQLObjectType,\n  GraphQLInputObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLList,\n  GraphQLNonNull\n} from './definition';\nimport type { GraphQLType, GraphQLAbstractType } from './definition';\nimport { GraphQLDirective, specifiedDirectives } from './directives';\nimport { __Schema } from './introspection';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport { isEqualType, isTypeSubTypeOf } from '../utilities/typeComparators';\n\n\n/**\n * Schema Definition\n *\n * A Schema is created by supplying the root types of each type of operation,\n * query and mutation (optional). A schema definition is then supplied to the\n * validator and executor.\n *\n * Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       query: MyAppQueryRootType,\n *       mutation: MyAppMutationRootType,\n *     })\n *\n * Note: If an array of `directives` are provided to GraphQLSchema, that will be\n * the exact list of directives represented and allowed. If `directives` is not\n * provided then a default set of the specified directives (e.g. @include and\n * @skip) will be used. If you wish to provide *additional* directives to these\n * specified directives, you must explicitly declare them. Example:\n *\n *     const MyAppSchema = new GraphQLSchema({\n *       ...\n *       directives: specifiedDirectives.concat([ myCustomDirective ]),\n *     })\n *\n */\nexport class GraphQLSchema {\n  _queryType: GraphQLObjectType;\n  _mutationType: ?GraphQLObjectType;\n  _subscriptionType: ?GraphQLObjectType;\n  _directives: Array<GraphQLDirective>;\n  _typeMap: TypeMap;\n  _implementations: { [interfaceName: string]: Array<GraphQLObjectType> };\n  _possibleTypeMap:\n    ?{ [abstractName: string]: { [possibleName: string]: boolean } };\n\n  constructor(config: GraphQLSchemaConfig) {\n    invariant(\n      typeof config === 'object',\n      'Must provide configuration object.'\n    );\n\n    invariant(\n      config.query instanceof GraphQLObjectType,\n      `Schema query must be Object Type but got: ${config.query}.`\n    );\n    this._queryType = config.query;\n\n    invariant(\n      !config.mutation || config.mutation instanceof GraphQLObjectType,\n      `Schema mutation must be Object Type if provided but got: ${\n        config.mutation}.`\n    );\n    this._mutationType = config.mutation;\n\n    invariant(\n      !config.subscription || config.subscription instanceof GraphQLObjectType,\n      `Schema subscription must be Object Type if provided but got: ${\n        config.subscription}.`\n    );\n    this._subscriptionType = config.subscription;\n\n    invariant(\n      !config.types || Array.isArray(config.types),\n      `Schema types must be Array if provided but got: ${config.types}.`\n    );\n\n    invariant(\n      !config.directives ||\n      Array.isArray(config.directives) && config.directives.every(\n        directive => directive instanceof GraphQLDirective\n      ),\n      `Schema directives must be Array<GraphQLDirective> if provided but got: ${\n        config.directives}.`\n    );\n    // Provide specified directives (e.g. @include and @skip) by default.\n    this._directives = config.directives || specifiedDirectives;\n\n    // Build type map now to detect any errors within this schema.\n    let initialTypes: Array<?GraphQLType> = [\n      this.getQueryType(),\n      this.getMutationType(),\n      this.getSubscriptionType(),\n      __Schema\n    ];\n\n    const types = config.types;\n    if (types) {\n      initialTypes = initialTypes.concat(types);\n    }\n\n    this._typeMap = initialTypes.reduce(\n      typeMapReducer,\n      (Object.create(null): TypeMap)\n    );\n\n    // Keep track of all implementations by interface name.\n    this._implementations = Object.create(null);\n    Object.keys(this._typeMap).forEach(typeName => {\n      const type = this._typeMap[typeName];\n      if (type instanceof GraphQLObjectType) {\n        type.getInterfaces().forEach(iface => {\n          const impls = this._implementations[iface.name];\n          if (impls) {\n            impls.push(type);\n          } else {\n            this._implementations[iface.name] = [ type ];\n          }\n        });\n      }\n    });\n\n    // Enforce correct interface implementations.\n    Object.keys(this._typeMap).forEach(typeName => {\n      const type = this._typeMap[typeName];\n      if (type instanceof GraphQLObjectType) {\n        type.getInterfaces().forEach(\n          iface => assertObjectImplementsInterface(this, type, iface)\n        );\n      }\n    });\n  }\n\n  getQueryType(): GraphQLObjectType {\n    return this._queryType;\n  }\n\n  getMutationType(): ?GraphQLObjectType {\n    return this._mutationType;\n  }\n\n  getSubscriptionType(): ?GraphQLObjectType {\n    return this._subscriptionType;\n  }\n\n  getTypeMap(): TypeMap {\n    return this._typeMap;\n  }\n\n  getType(name: string): ?GraphQLType {\n    return this.getTypeMap()[name];\n  }\n\n  getPossibleTypes(\n    abstractType: GraphQLAbstractType\n  ): Array<GraphQLObjectType> {\n    if (abstractType instanceof GraphQLUnionType) {\n      return abstractType.getTypes();\n    }\n    invariant(abstractType instanceof GraphQLInterfaceType);\n    return this._implementations[abstractType.name];\n  }\n\n  isPossibleType(\n    abstractType: GraphQLAbstractType,\n    possibleType: GraphQLObjectType\n  ): boolean {\n    let possibleTypeMap = this._possibleTypeMap;\n    if (!possibleTypeMap) {\n      this._possibleTypeMap = possibleTypeMap = Object.create(null);\n    }\n\n    if (!possibleTypeMap[abstractType.name]) {\n      const possibleTypes = this.getPossibleTypes(abstractType);\n      invariant(\n        Array.isArray(possibleTypes),\n        `Could not find possible implementing types for ${abstractType} in ` +\n        'schema. Check that schema.types is defined and is an array of' +\n        'all possible types in the schema.'\n      );\n      possibleTypeMap[abstractType.name] =\n        possibleTypes.reduce(\n          (map, type) => ((map[type.name] = true), map),\n          Object.create(null)\n        );\n    }\n\n    return Boolean(possibleTypeMap[abstractType.name][possibleType.name]);\n  }\n\n  getDirectives(): Array<GraphQLDirective> {\n    return this._directives;\n  }\n\n  getDirective(name: string): ?GraphQLDirective {\n    return find(this.getDirectives(), directive => directive.name === name);\n  }\n}\n\ntype TypeMap = { [typeName: string]: GraphQLType }\n\ntype GraphQLSchemaConfig = {\n  query: GraphQLObjectType;\n  mutation?: ?GraphQLObjectType;\n  subscription?: ?GraphQLObjectType;\n  types?: ?Array<GraphQLType>;\n  directives?: ?Array<GraphQLDirective>;\n}\n\nfunction typeMapReducer(map: TypeMap, type: ?GraphQLType): TypeMap {\n  if (!type) {\n    return map;\n  }\n  if (type instanceof GraphQLList || type instanceof GraphQLNonNull) {\n    return typeMapReducer(map, type.ofType);\n  }\n  if (map[type.name]) {\n    invariant(\n      map[type.name] === type,\n      'Schema must contain unique named types but contains multiple ' +\n      `types named \"${type}\".`\n    );\n    return map;\n  }\n  map[type.name] = type;\n\n  let reducedMap = map;\n\n  if (type instanceof GraphQLUnionType) {\n    reducedMap = type.getTypes().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof GraphQLObjectType) {\n    reducedMap = type.getInterfaces().reduce(typeMapReducer, reducedMap);\n  }\n\n  if (type instanceof GraphQLObjectType ||\n      type instanceof GraphQLInterfaceType ||\n      type instanceof GraphQLInputObjectType) {\n    const fieldMap = type.getFields();\n    Object.keys(fieldMap).forEach(fieldName => {\n      const field = fieldMap[fieldName];\n\n      if (field.args) {\n        const fieldArgTypes = field.args.map(arg => arg.type);\n        reducedMap = fieldArgTypes.reduce(typeMapReducer, reducedMap);\n      }\n      reducedMap = typeMapReducer(reducedMap, field.type);\n    });\n  }\n\n  return reducedMap;\n}\n\nfunction assertObjectImplementsInterface(\n  schema: GraphQLSchema,\n  object: GraphQLObjectType,\n  iface: GraphQLInterfaceType\n): void {\n  const objectFieldMap = object.getFields();\n  const ifaceFieldMap = iface.getFields();\n\n  // Assert each interface field is implemented.\n  Object.keys(ifaceFieldMap).forEach(fieldName => {\n    const objectField = objectFieldMap[fieldName];\n    const ifaceField = ifaceFieldMap[fieldName];\n\n    // Assert interface field exists on object.\n    invariant(\n      objectField,\n      `\"${iface}\" expects field \"${fieldName}\" but \"${object}\" does not ` +\n      'provide it.'\n    );\n\n    // Assert interface field type is satisfied by object field type, by being\n    // a valid subtype. (covariant)\n    invariant(\n      isTypeSubTypeOf(schema, objectField.type, ifaceField.type),\n      `${iface}.${fieldName} expects type \"${ifaceField.type}\" but ` +\n      `${object}.${fieldName} provides type \"${objectField.type}\".`\n    );\n\n    // Assert each interface field arg is implemented.\n    ifaceField.args.forEach(ifaceArg => {\n      const argName = ifaceArg.name;\n      const objectArg = find(objectField.args, arg => arg.name === argName);\n\n      // Assert interface field arg exists on object field.\n      invariant(\n        objectArg,\n        `${iface}.${fieldName} expects argument \"${argName}\" but ` +\n        `${object}.${fieldName} does not provide it.`\n      );\n\n      // Assert interface field arg type matches object field arg type.\n      // (invariant)\n      invariant(\n        isEqualType(ifaceArg.type, objectArg.type),\n        `${iface}.${fieldName}(${argName}:) expects type \"${ifaceArg.type}\" ` +\n        `but ${object}.${fieldName}(${argName}:) provides ` +\n        `type \"${objectArg.type}\".`\n      );\n    });\n\n    // Assert additional arguments must not be required.\n    objectField.args.forEach(objectArg => {\n      const argName = objectArg.name;\n      const ifaceArg = find(ifaceField.args, arg => arg.name === argName);\n      if (!ifaceArg) {\n        invariant(\n          !(objectArg.type instanceof GraphQLNonNull),\n          `${object}.${fieldName}(${argName}:) is of required type ` +\n          `\"${objectArg.type}\" but is not also provided by the ` +\n          `interface ${iface}.${fieldName}.`\n        );\n      }\n    });\n  });\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}