{"version":3,"sources":["type/definition.js"],"names":[],"mappings":"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","file":"type/definition.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport invariant from '../jsutils/invariant';\nimport isNullish from '../jsutils/isNullish';\nimport { ENUM } from '../language/kinds';\nimport { assertValidName } from '../utilities/assertValidName';\nimport type {\n  OperationDefinition,\n  Field,\n  FragmentDefinition,\n  Value,\n} from '../language/ast';\nimport type { GraphQLSchema } from './schema';\n\n\n// Predicates\n\n/**\n * These are all of the possible kinds of types.\n */\nexport type GraphQLType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList |\n  GraphQLNonNull;\n\nexport function isType(type: mixed): boolean {\n  return (\n    type instanceof GraphQLScalarType ||\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType ||\n    type instanceof GraphQLEnumType ||\n    type instanceof GraphQLInputObjectType ||\n    type instanceof GraphQLList ||\n    type instanceof GraphQLNonNull\n  );\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nexport type GraphQLInputType =\n  GraphQLScalarType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList<GraphQLInputType> |\n  GraphQLNonNull<\n    GraphQLScalarType |\n    GraphQLEnumType |\n    GraphQLInputObjectType |\n    GraphQLList<GraphQLInputType>\n  >;\n\nexport function isInputType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLEnumType ||\n    namedType instanceof GraphQLInputObjectType\n  );\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\nexport type GraphQLOutputType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLList<GraphQLOutputType> |\n  GraphQLNonNull<\n    GraphQLScalarType |\n    GraphQLObjectType |\n    GraphQLInterfaceType |\n    GraphQLUnionType |\n    GraphQLEnumType |\n    GraphQLList<GraphQLOutputType>\n  >;\n\nexport function isOutputType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLObjectType ||\n    namedType instanceof GraphQLInterfaceType ||\n    namedType instanceof GraphQLUnionType ||\n    namedType instanceof GraphQLEnumType\n  );\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\nexport type GraphQLLeafType =\n  GraphQLScalarType |\n  GraphQLEnumType;\n\nexport function isLeafType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLEnumType\n  );\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLCompositeType =\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType;\n\nexport function isCompositeType(type: ?GraphQLType): boolean {\n  return (\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType\n  );\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLAbstractType =\n  GraphQLInterfaceType |\n  GraphQLUnionType;\n\nexport function isAbstractType(type: ?GraphQLType): boolean {\n  return (\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType\n  );\n}\n\n/**\n * These types can all accept null as a value.\n */\nexport type GraphQLNullableType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList;\n\nexport function getNullableType(type: ?GraphQLType): ?GraphQLNullableType {\n  return type instanceof GraphQLNonNull ? type.ofType : type;\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexport type GraphQLNamedType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType;\n\nexport function getNamedType(type: ?GraphQLType): ?GraphQLNamedType {\n  let unmodifiedType = type;\n  while (\n    unmodifiedType instanceof GraphQLList ||\n    unmodifiedType instanceof GraphQLNonNull\n  ) {\n    unmodifiedType = unmodifiedType.ofType;\n  }\n  return unmodifiedType;\n}\n\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         return value % 2 === 1 ? value : null;\n *       }\n *     });\n *\n */\nexport class GraphQLScalarType<InternalType> {\n  name: string;\n  description: ?string;\n\n  _scalarConfig: GraphQLScalarTypeConfig<InternalType>;\n\n  constructor(config: GraphQLScalarTypeConfig<InternalType>) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    invariant(\n      typeof config.serialize === 'function',\n      `${this} must provide \"serialize\" function. If this custom Scalar is ` +\n      'also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' +\n      'functions are also provided.'\n    );\n    if (config.parseValue || config.parseLiteral) {\n      invariant(\n        typeof config.parseValue === 'function' &&\n        typeof config.parseLiteral === 'function',\n        `${this} must provide both \"parseValue\" and \"parseLiteral\" functions.`\n      );\n    }\n    this._scalarConfig = config;\n  }\n\n  serialize(value: mixed): ?InternalType {\n    const serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  }\n\n  parseValue(value: mixed): ?InternalType {\n    const parser = this._scalarConfig.parseValue;\n    return parser ? parser(value) : null;\n  }\n\n  parseLiteral(valueAST: Value): ?InternalType {\n    const parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueAST) : null;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLScalarTypeConfig<InternalType> = {\n  name: string;\n  description?: ?string;\n  serialize: (value: mixed) => ?InternalType;\n  parseValue?: (value: mixed) => ?InternalType;\n  parseLiteral?: (valueAST: Value) => ?InternalType;\n}\n\n\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport class GraphQLObjectType {\n  name: string;\n  description: ?string;\n  isTypeOf: ?GraphQLIsTypeOfFn;\n\n  _typeConfig: GraphQLObjectTypeConfig;\n  _fields: GraphQLFieldDefinitionMap;\n  _interfaces: Array<GraphQLInterfaceType>;\n\n  constructor(config: GraphQLObjectTypeConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.isTypeOf) {\n      invariant(\n        typeof config.isTypeOf === 'function',\n        `${this} must provide \"isTypeOf\" as a function.`\n      );\n    }\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n  }\n\n  getFields(): GraphQLFieldDefinitionMap {\n    return this._fields || (this._fields =\n      defineFieldMap(this, this._typeConfig.fields)\n    );\n  }\n\n  getInterfaces(): Array<GraphQLInterfaceType> {\n    return this._interfaces || (this._interfaces =\n      defineInterfaces(this, this._typeConfig.interfaces)\n    );\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nfunction resolveMaybeThunk<T>(thingOrThunk: T | () => T): T {\n  return typeof thingOrThunk === 'function' ? thingOrThunk() : thingOrThunk;\n}\n\nfunction defineInterfaces(\n  type: GraphQLObjectType,\n  interfacesOrThunk: Array<GraphQLInterfaceType> | ?GraphQLInterfacesThunk\n): Array<GraphQLInterfaceType> {\n  const interfaces = resolveMaybeThunk(interfacesOrThunk);\n  if (!interfaces) {\n    return [];\n  }\n  invariant(\n    Array.isArray(interfaces),\n    `${type} interfaces must be an Array or a function which returns an Array.`\n  );\n  interfaces.forEach(iface => {\n    invariant(\n      iface instanceof GraphQLInterfaceType,\n      `${type} may only implement Interface types, it cannot ` +\n      `implement: ${iface}.`\n    );\n    if (typeof iface.resolveType !== 'function') {\n      invariant(\n        typeof type.isTypeOf === 'function',\n        `Interface Type ${iface} does not provide a \"resolveType\" function ` +\n        `and implementing Type ${type} does not provide a \"isTypeOf\" ` +\n        'function. There is no way to resolve this implementing type ' +\n        'during execution.'\n      );\n    }\n  });\n  return interfaces;\n}\n\nfunction defineFieldMap(\n  type: GraphQLNamedType,\n  fields: GraphQLFieldConfigMap | GraphQLFieldConfigMapThunk\n): GraphQLFieldDefinitionMap {\n  const fieldMap: any = resolveMaybeThunk(fields);\n  invariant(\n    isPlainObj(fieldMap),\n    `${type} fields must be an object with field names as keys or a ` +\n    'function which returns such an object.'\n  );\n\n  const fieldNames = Object.keys(fieldMap);\n  invariant(\n    fieldNames.length > 0,\n    `${type} fields must be an object with field names as keys or a ` +\n    'function which returns such an object.'\n  );\n\n  const resultFieldMap = {};\n  fieldNames.forEach(fieldName => {\n    assertValidName(fieldName);\n    const field = {\n      ...fieldMap[fieldName],\n      name: fieldName\n    };\n    invariant(\n      !field.hasOwnProperty('isDeprecated'),\n      `${type}.${fieldName} should provide \"deprecationReason\" instead ` +\n      'of \"isDeprecated\".'\n    );\n    invariant(\n      isOutputType(field.type),\n      `${type}.${fieldName} field type must be Output Type but ` +\n      `got: ${field.type}.`\n    );\n    if (!field.args) {\n      field.args = [];\n    } else {\n      invariant(\n        isPlainObj(field.args),\n        `${type}.${fieldName} args must be an object with argument names ` +\n        'as keys.'\n      );\n      field.args = Object.keys(field.args).map(argName => {\n        assertValidName(argName);\n        const arg = field.args[argName];\n        invariant(\n          isInputType(arg.type),\n          `${type}.${fieldName}(${argName}:) argument type must be ` +\n          `Input Type but got: ${arg.type}.`\n        );\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue\n        };\n      });\n    }\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && typeof obj === 'object' && !Array.isArray(obj);\n}\n\nexport type GraphQLObjectTypeConfig = {\n  name: string;\n  interfaces?: GraphQLInterfacesThunk | Array<GraphQLInterfaceType>;\n  fields: GraphQLFieldConfigMapThunk | GraphQLFieldConfigMap;\n  isTypeOf?: GraphQLIsTypeOfFn;\n  description?: ?string\n}\n\ntype GraphQLInterfacesThunk = () => Array<GraphQLInterfaceType>;\n\ntype GraphQLFieldConfigMapThunk = () => GraphQLFieldConfigMap;\n\nexport type GraphQLTypeResolveFn = (\n  value: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo\n) => ?GraphQLObjectType\n\nexport type GraphQLIsTypeOfFn = (\n  value: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo\n) => boolean\n\nexport type GraphQLFieldResolveFn = (\n  source: mixed,\n  args: {[argName: string]: mixed},\n  context: mixed,\n  info: GraphQLResolveInfo\n) => mixed\n\nexport type GraphQLResolveInfo = {\n  fieldName: string,\n  fieldASTs: Array<Field>,\n  returnType: GraphQLOutputType,\n  parentType: GraphQLCompositeType,\n  schema: GraphQLSchema,\n  fragments: { [fragmentName: string]: FragmentDefinition },\n  rootValue: mixed,\n  operation: OperationDefinition,\n  variableValues: { [variableName: string]: mixed },\n}\n\nexport type GraphQLFieldConfig = {\n  type: GraphQLOutputType;\n  args?: GraphQLFieldConfigArgumentMap;\n  resolve?: GraphQLFieldResolveFn;\n  deprecationReason?: ?string;\n  description?: ?string;\n}\n\nexport type GraphQLFieldConfigArgumentMap = {\n  [argName: string]: GraphQLArgumentConfig;\n};\n\nexport type GraphQLArgumentConfig = {\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type GraphQLFieldConfigMap = {\n  [fieldName: string]: GraphQLFieldConfig;\n};\n\nexport type GraphQLFieldDefinition = {\n  name: string;\n  description: ?string;\n  type: GraphQLOutputType;\n  args: Array<GraphQLArgument>;\n  resolve?: GraphQLFieldResolveFn;\n  deprecationReason?: ?string;\n}\n\nexport type GraphQLArgument = {\n  name: string;\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n};\n\nexport type GraphQLFieldDefinitionMap = {\n  [fieldName: string]: GraphQLFieldDefinition;\n};\n\n\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport class GraphQLInterfaceType {\n  name: string;\n  description: ?string;\n  resolveType: ?GraphQLTypeResolveFn;\n\n  _typeConfig: GraphQLInterfaceTypeConfig;\n  _fields: GraphQLFieldDefinitionMap;\n\n  constructor(config: GraphQLInterfaceTypeConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      invariant(\n        typeof config.resolveType === 'function',\n        `${this} must provide \"resolveType\" as a function.`\n      );\n    }\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  getFields(): GraphQLFieldDefinitionMap {\n    return this._fields ||\n      (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLInterfaceTypeConfig = {\n  name: string,\n  fields: GraphQLFieldConfigMapThunk | GraphQLFieldConfigMap,\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: GraphQLTypeResolveFn,\n  description?: ?string\n};\n\n\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport class GraphQLUnionType {\n  name: string;\n  description: ?string;\n  resolveType: ?GraphQLTypeResolveFn;\n\n  _typeConfig: GraphQLUnionTypeConfig;\n  _types: Array<GraphQLObjectType>;\n  _possibleTypeNames: {[typeName: string]: boolean};\n\n  constructor(config: GraphQLUnionTypeConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      invariant(\n        typeof config.resolveType === 'function',\n        `${this} must provide \"resolveType\" as a function.`\n      );\n    }\n    this.resolveType = config.resolveType;\n    invariant(\n      Array.isArray(config.types) && config.types.length > 0,\n      `Must provide Array of types for Union ${config.name}.`\n    );\n    config.types.forEach(type => {\n      invariant(\n        type instanceof GraphQLObjectType,\n        `${this} may only contain Object types, it cannot contain: ${type}.`\n      );\n      if (typeof this.resolveType !== 'function') {\n        invariant(\n          typeof type.isTypeOf === 'function',\n          `Union Type ${this} does not provide a \"resolveType\" function ` +\n          `and possible Type ${type} does not provide a \"isTypeOf\" ` +\n          'function. There is no way to resolve this possible type ' +\n          'during execution.'\n        );\n      }\n    });\n    this._types = config.types;\n    this._typeConfig = config;\n  }\n\n  getTypes(): Array<GraphQLObjectType> {\n    return this._types;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLUnionTypeConfig = {\n  name: string,\n  types: Array<GraphQLObjectType>,\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: GraphQLTypeResolveFn;\n  description?: ?string;\n};\n\n\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType/* <T> */ {\n  name: string;\n  description: ?string;\n\n  _enumConfig: GraphQLEnumTypeConfig/* <T> */;\n  _values: Array<GraphQLEnumValueDefinition/* <T> */>;\n  _valueLookup: Map<any/* T */, GraphQLEnumValueDefinition>;\n  _nameLookup: { [valueName: string]: GraphQLEnumValueDefinition };\n\n  constructor(config: GraphQLEnumTypeConfig/* <T> */) {\n    this.name = config.name;\n    assertValidName(config.name);\n    this.description = config.description;\n    this._values = defineEnumValues(this, config.values);\n    this._enumConfig = config;\n  }\n\n  getValues(): Array<GraphQLEnumValueDefinition/* <T> */> {\n    return this._values;\n  }\n\n  serialize(value: any/* T */): ?string {\n    const enumValue = this._getValueLookup().get(value);\n    return enumValue ? enumValue.name : null;\n  }\n\n  parseValue(value: mixed): ?any/* T */ {\n    if (typeof value === 'string') {\n      const enumValue = this._getNameLookup()[value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  }\n\n  parseLiteral(valueAST: Value): ?any/* T */ {\n    if (valueAST.kind === ENUM) {\n      const enumValue = this._getNameLookup()[valueAST.value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  }\n\n  _getValueLookup(): Map<any/* T */, GraphQLEnumValueDefinition> {\n    if (!this._valueLookup) {\n      const lookup = new Map();\n      this.getValues().forEach(value => {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n    return this._valueLookup;\n  }\n\n  _getNameLookup(): { [valueName: string]: GraphQLEnumValueDefinition } {\n    if (!this._nameLookup) {\n      const lookup = Object.create(null);\n      this.getValues().forEach(value => {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n    return this._nameLookup;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nfunction defineEnumValues(\n  type: GraphQLEnumType,\n  valueMap: GraphQLEnumValueConfigMap/* <T> */\n): Array<GraphQLEnumValueDefinition/* <T> */> {\n  invariant(\n    isPlainObj(valueMap),\n    `${type} values must be an object with value names as keys.`\n  );\n  const valueNames = Object.keys(valueMap);\n  invariant(\n    valueNames.length > 0,\n    `${type} values must be an object with value names as keys.`\n  );\n  return valueNames.map(valueName => {\n    assertValidName(valueName);\n    const value = valueMap[valueName];\n    invariant(\n      isPlainObj(value),\n      `${type}.${valueName} must refer to an object with a \"value\" key ` +\n      `representing an internal value but got: ${value}.`\n    );\n    invariant(\n      !value.hasOwnProperty('isDeprecated'),\n      `${type}.${valueName} should provide \"deprecationReason\" instead ` +\n      'of \"isDeprecated\".'\n    );\n    return {\n      name: valueName,\n      description: value.description,\n      deprecationReason: value.deprecationReason,\n      value: isNullish(value.value) ? valueName : value.value,\n    };\n  });\n}\n\nexport type GraphQLEnumTypeConfig/* <T> */ = {\n  name: string;\n  values: GraphQLEnumValueConfigMap/* <T> */;\n  description?: ?string;\n}\n\nexport type GraphQLEnumValueConfigMap/* <T> */ = {\n  [valueName: string]: GraphQLEnumValueConfig/* <T> */;\n};\n\nexport type GraphQLEnumValueConfig/* <T> */ = {\n  value?: any/* T */;\n  deprecationReason?: ?string;\n  description?: ?string;\n}\n\nexport type GraphQLEnumValueDefinition/* <T> */ = {\n  name: string;\n  description: ?string;\n  deprecationReason: ?string;\n  value: any/* T */;\n}\n\n\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport class GraphQLInputObjectType {\n  name: string;\n  description: ?string;\n\n  _typeConfig: InputObjectConfig;\n  _fields: InputObjectFieldMap;\n\n  constructor(config: InputObjectConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this._typeConfig = config;\n  }\n\n  getFields(): InputObjectFieldMap {\n    return this._fields || (this._fields = this._defineFieldMap());\n  }\n\n  _defineFieldMap(): InputObjectFieldMap {\n    const fieldMap: any = resolveMaybeThunk(this._typeConfig.fields);\n    invariant(\n      isPlainObj(fieldMap),\n      `${this} fields must be an object with field names as keys or a ` +\n      'function which returns such an object.'\n    );\n    const fieldNames = Object.keys(fieldMap);\n    invariant(\n      fieldNames.length > 0,\n      `${this} fields must be an object with field names as keys or a ` +\n      'function which returns such an object.'\n    );\n    const resultFieldMap = {};\n    fieldNames.forEach(fieldName => {\n      assertValidName(fieldName);\n      const field = {\n        ...fieldMap[fieldName],\n        name: fieldName\n      };\n      invariant(\n        isInputType(field.type),\n        `${this}.${fieldName} field type must be Input Type but ` +\n        `got: ${field.type}.`\n      );\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type InputObjectConfig = {\n  name: string;\n  fields: InputObjectConfigFieldMapThunk | InputObjectConfigFieldMap;\n  description?: ?string;\n}\n\ntype InputObjectConfigFieldMapThunk = () => InputObjectConfigFieldMap;\n\nexport type InputObjectFieldConfig = {\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type InputObjectConfigFieldMap = {\n  [fieldName: string]: InputObjectFieldConfig;\n};\n\nexport type InputObjectField = {\n  name: string;\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type InputObjectFieldMap = {\n  [fieldName: string]: InputObjectField;\n};\n\n\n\n/**\n * List Modifier\n *\n * A list is a kind of type marker, a wrapping type which points to another\n * type. Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(Person) },\n *         children: { type: new GraphQLList(Person) },\n *       })\n *     })\n *\n */\nexport class GraphQLList<T: GraphQLType> {\n  ofType: T;\n\n  constructor(type: T) {\n    invariant(\n      isType(type),\n      `Can only create List of a GraphQLType but got: ${type}.`\n    );\n    this.ofType = type;\n  }\n\n  toString(): string {\n    return '[' + String(this.ofType) + ']';\n  }\n}\n\n\n/**\n * Non-Null Modifier\n *\n * A non-null is a kind of type marker, a wrapping type which points to another\n * type. Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\nexport class GraphQLNonNull<T: GraphQLNullableType> {\n  ofType: T;\n\n  constructor(type: T) {\n    invariant(\n      isType(type) && !(type instanceof GraphQLNonNull),\n      `Can only create NonNull of a Nullable GraphQLType but got: ${type}.`\n    );\n    this.ofType = type;\n  }\n\n  toString(): string {\n    return this.ofType.toString() + '!';\n  }\n}\n\nexport type {\n  OperationDefinition,\n  Field,\n  FragmentDefinition,\n  Value\n};\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}