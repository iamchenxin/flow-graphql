{"version":3,"sources":["type/definition.js"],"names":[],"mappings":"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","file":"type/definition.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport invariant from '../jsutils/invariant';\nimport isNullish from '../jsutils/isNullish';\nimport { ENUM } from '../language/kinds';\nimport { assertValidName } from '../utilities/assertValidName';\nimport type {\n  OperationDefinition,\n  Field,\n  FragmentDefinition,\n  Value,\n} from '../language/ast';\nimport type { GraphQLSchema } from './schema';\n\n\n// Predicates\n\n/**\n * These are all of the possible kinds of types.\n */\nexport type GraphQLType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList<any> |\n  GraphQLNonNull<any>;\n\nexport function isType(type: mixed): boolean {\n  return (\n    type instanceof GraphQLScalarType ||\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType ||\n    type instanceof GraphQLEnumType ||\n    type instanceof GraphQLInputObjectType ||\n    type instanceof GraphQLList ||\n    type instanceof GraphQLNonNull\n  );\n}\n\n/**\n * These types may be used as input types for arguments and directives.\n */\nexport type GraphQLInputType =\n  GraphQLScalarType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList<GraphQLInputType> |\n  GraphQLNonNull<\n    GraphQLScalarType |\n    GraphQLEnumType |\n    GraphQLInputObjectType |\n    GraphQLList<GraphQLInputType>\n  >;\n\nexport function isInputType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLEnumType ||\n    namedType instanceof GraphQLInputObjectType\n  );\n}\n\n/**\n * These types may be used as output types as the result of fields.\n */\nexport type GraphQLOutputType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLList<GraphQLOutputType> |\n  GraphQLNonNull<\n    GraphQLScalarType |\n    GraphQLObjectType |\n    GraphQLInterfaceType |\n    GraphQLUnionType |\n    GraphQLEnumType |\n    GraphQLList<GraphQLOutputType>\n  >;\n\nexport function isOutputType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLObjectType ||\n    namedType instanceof GraphQLInterfaceType ||\n    namedType instanceof GraphQLUnionType ||\n    namedType instanceof GraphQLEnumType\n  );\n}\n\n/**\n * These types may describe types which may be leaf values.\n */\nexport type GraphQLLeafType =\n  GraphQLScalarType |\n  GraphQLEnumType;\n\nexport function isLeafType(type: ?GraphQLType): boolean {\n  const namedType = getNamedType(type);\n  return (\n    namedType instanceof GraphQLScalarType ||\n    namedType instanceof GraphQLEnumType\n  );\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLCompositeType =\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType;\n\nexport function isCompositeType(type: ?GraphQLType): boolean {\n  return (\n    type instanceof GraphQLObjectType ||\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType\n  );\n}\n\n/**\n * These types may describe the parent context of a selection set.\n */\nexport type GraphQLAbstractType =\n  GraphQLInterfaceType |\n  GraphQLUnionType;\n\nexport function isAbstractType(type: ?GraphQLType): boolean {\n  return (\n    type instanceof GraphQLInterfaceType ||\n    type instanceof GraphQLUnionType\n  );\n}\n\n/**\n * These types can all accept null as a value.\n */\nexport type GraphQLNullableType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType |\n  GraphQLList<*>;\n\nexport function getNullableType<T: GraphQLType>(\n  type: ?T\n): ?(T & GraphQLNullableType) {\n  return type instanceof GraphQLNonNull ? type.ofType : type;\n}\n\n/**\n * These named types do not include modifiers like List or NonNull.\n */\nexport type GraphQLNamedType =\n  GraphQLScalarType |\n  GraphQLObjectType |\n  GraphQLInterfaceType |\n  GraphQLUnionType |\n  GraphQLEnumType |\n  GraphQLInputObjectType;\n\nexport function getNamedType(type: ?GraphQLType): ?GraphQLNamedType {\n  let unmodifiedType = type;\n  while (\n    unmodifiedType instanceof GraphQLList ||\n    unmodifiedType instanceof GraphQLNonNull\n  ) {\n    unmodifiedType = unmodifiedType.ofType;\n  }\n  return unmodifiedType;\n}\n\n\n/**\n * Used while defining GraphQL types to allow for circular references in\n * otherwise immutable type definitions.\n */\nexport type Thunk<T> = (() => T) | T;\n\nfunction resolveThunk<T>(thunk: Thunk<T>): T {\n  return typeof thunk === 'function' ? thunk() : thunk;\n}\n\n\n/**\n * Scalar Type Definition\n *\n * The leaf values of any request and input values to arguments are\n * Scalars (or Enums) and are defined with a name and a series of functions\n * used to parse input from ast or variables and to ensure validity.\n *\n * Example:\n *\n *     const OddType = new GraphQLScalarType({\n *       name: 'Odd',\n *       serialize(value) {\n *         return value % 2 === 1 ? value : null;\n *       }\n *     });\n *\n */\nexport class GraphQLScalarType {\n  name: string;\n  description: ?string;\n\n  _scalarConfig: GraphQLScalarTypeConfig<*, *>;\n\n  constructor(config: GraphQLScalarTypeConfig<*, *>) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    invariant(\n      typeof config.serialize === 'function',\n      `${this.name} must provide \"serialize\" function. If this custom Scalar ` +\n      'is also used as an input type, ensure \"parseValue\" and \"parseLiteral\" ' +\n      'functions are also provided.'\n    );\n    if (config.parseValue || config.parseLiteral) {\n      invariant(\n        typeof config.parseValue === 'function' &&\n        typeof config.parseLiteral === 'function',\n        `${this.name} must provide both \"parseValue\" and \"parseLiteral\" ` +\n        'functions.'\n      );\n    }\n    this._scalarConfig = config;\n  }\n\n  // Serializes an internal value to include an a response.\n  serialize(value: mixed): mixed {\n    const serializer = this._scalarConfig.serialize;\n    return serializer(value);\n  }\n\n  // Parses an externally provided value to use as an input.\n  parseValue(value: mixed): mixed {\n    const parser = this._scalarConfig.parseValue;\n    return parser ? parser(value) : null;\n  }\n\n  // Parses an externally provided literal value to use as an input.\n  parseLiteral(valueAST: Value): mixed {\n    const parser = this._scalarConfig.parseLiteral;\n    return parser ? parser(valueAST) : null;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLScalarTypeConfig<TInternal, TExternal> = {\n  name: string;\n  description?: ?string;\n  serialize: (value: mixed) => ?TExternal;\n  parseValue?: (value: mixed) => ?TInternal;\n  parseLiteral?: (valueAST: Value) => ?TInternal;\n}\n\n\n\n/**\n * Object Type Definition\n *\n * Almost all of the GraphQL types you define will be object types. Object types\n * have a name, but most importantly describe their fields.\n *\n * Example:\n *\n *     const AddressType = new GraphQLObjectType({\n *       name: 'Address',\n *       fields: {\n *         street: { type: GraphQLString },\n *         number: { type: GraphQLInt },\n *         formatted: {\n *           type: GraphQLString,\n *           resolve(obj) {\n *             return obj.number + ' ' + obj.street\n *           }\n *         }\n *       }\n *     });\n *\n * When two types need to refer to each other, or a type needs to refer to\n * itself in a field, you can use a function expression (aka a closure or a\n * thunk) to supply the fields lazily.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         name: { type: GraphQLString },\n *         bestFriend: { type: PersonType },\n *       })\n *     });\n *\n */\nexport class GraphQLObjectType {\n  name: string;\n  description: ?string;\n  isTypeOf: ?GraphQLIsTypeOfFn;\n\n  _typeConfig: GraphQLObjectTypeConfig<*>;\n  _fields: GraphQLFieldDefinitionMap;\n  _interfaces: Array<GraphQLInterfaceType>;\n\n  constructor(config: GraphQLObjectTypeConfig<*>) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.isTypeOf) {\n      invariant(\n        typeof config.isTypeOf === 'function',\n        `${this.name} must provide \"isTypeOf\" as a function.`\n      );\n    }\n    this.isTypeOf = config.isTypeOf;\n    this._typeConfig = config;\n  }\n\n  getFields(): GraphQLFieldDefinitionMap {\n    return this._fields || (this._fields =\n      defineFieldMap(this, this._typeConfig.fields)\n    );\n  }\n\n  getInterfaces(): Array<GraphQLInterfaceType> {\n    return this._interfaces || (this._interfaces =\n      defineInterfaces(this, this._typeConfig.interfaces)\n    );\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nfunction defineInterfaces(\n  type: GraphQLObjectType,\n  interfacesThunk: Thunk<?Array<GraphQLInterfaceType>>\n): Array<GraphQLInterfaceType> {\n  const interfaces = resolveThunk(interfacesThunk);\n  if (!interfaces) {\n    return [];\n  }\n  invariant(\n    Array.isArray(interfaces),\n    `${type.name} interfaces must be an Array or a function which returns ` +\n    'an Array.'\n  );\n  interfaces.forEach(iface => {\n    invariant(\n      iface instanceof GraphQLInterfaceType,\n      `${type.name} may only implement Interface types, it cannot ` +\n      `implement: ${String(iface)}.`\n    );\n    if (typeof iface.resolveType !== 'function') {\n      invariant(\n        typeof type.isTypeOf === 'function',\n        `Interface Type ${iface.name} does not provide a \"resolveType\" ` +\n        `function and implementing Type ${type.name} does not provide a ` +\n        '\"isTypeOf\" function. There is no way to resolve this implementing ' +\n        'type during execution.'\n      );\n    }\n  });\n  return interfaces;\n}\n\nfunction defineFieldMap(\n  type: GraphQLNamedType,\n  fieldsThunk: Thunk<GraphQLFieldConfigMap<*>>\n): GraphQLFieldDefinitionMap {\n  const fieldMap = resolveThunk(fieldsThunk);\n  invariant(\n    isPlainObj(fieldMap),\n    `${type.name} fields must be an object with field names as keys or a ` +\n    'function which returns such an object.'\n  );\n\n  const fieldNames = Object.keys(fieldMap);\n  invariant(\n    fieldNames.length > 0,\n    `${type.name} fields must be an object with field names as keys or a ` +\n    'function which returns such an object.'\n  );\n\n  const resultFieldMap = {};\n  fieldNames.forEach(fieldName => {\n    assertValidName(fieldName);\n    const fieldConfig = fieldMap[fieldName];\n    const field = {\n      ...fieldConfig,\n      name: fieldName\n    };\n    invariant(\n      !field.hasOwnProperty('isDeprecated'),\n      `${type.name}.${fieldName} should provide \"deprecationReason\" instead ` +\n      'of \"isDeprecated\".'\n    );\n    invariant(\n      isOutputType(field.type),\n      `${type.name}.${fieldName} field type must be Output Type but ` +\n      `got: ${String(field.type)}.`\n    );\n    const argsConfig = fieldConfig.args;\n    if (!argsConfig) {\n      field.args = [];\n    } else {\n      invariant(\n        isPlainObj(argsConfig),\n        `${type.name}.${fieldName} args must be an object with argument ` +\n        'names as keys.'\n      );\n      field.args = Object.keys(argsConfig).map(argName => {\n        assertValidName(argName);\n        const arg = argsConfig[argName];\n        invariant(\n          isInputType(arg.type),\n          `${type.name}.${fieldName}(${argName}:) argument type must be ` +\n          `Input Type but got: ${String(arg.type)}.`\n        );\n        return {\n          name: argName,\n          description: arg.description === undefined ? null : arg.description,\n          type: arg.type,\n          defaultValue: arg.defaultValue === undefined ? null : arg.defaultValue\n        };\n      });\n    }\n    resultFieldMap[fieldName] = field;\n  });\n  return resultFieldMap;\n}\n\nfunction isPlainObj(obj) {\n  return obj && typeof obj === 'object' && !Array.isArray(obj);\n}\n\nexport type GraphQLObjectTypeConfig<TSource> = {\n  name: string;\n  interfaces?: Thunk<?Array<GraphQLInterfaceType>>;\n  fields: Thunk<GraphQLFieldConfigMap<TSource>>;\n  isTypeOf?: ?GraphQLIsTypeOfFn;\n  description?: ?string\n}\n\nexport type GraphQLTypeResolveFn = (\n  value: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo\n) => ?GraphQLObjectType\n\nexport type GraphQLIsTypeOfFn = (\n  source: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo\n) => boolean\n\nexport type GraphQLFieldResolveFn<TSource, TResult> = (\n  source: TSource,\n  args: {[argName: string]: mixed},\n  context: mixed,\n  info: GraphQLResolveInfo\n) => TResult\n\nexport type GraphQLResolveInfo = {\n  fieldName: string;\n  fieldASTs: Array<Field>;\n  returnType: GraphQLOutputType;\n  parentType: GraphQLCompositeType;\n  path: Array<string | number>;\n  schema: GraphQLSchema;\n  fragments: { [fragmentName: string]: FragmentDefinition };\n  rootValue: mixed;\n  operation: OperationDefinition;\n  variableValues: { [variableName: string]: mixed };\n}\n\nexport type GraphQLFieldConfig<TSource> = {\n  type: GraphQLOutputType;\n  args?: GraphQLFieldConfigArgumentMap;\n  resolve?: GraphQLFieldResolveFn<TSource, *>;\n  deprecationReason?: ?string;\n  description?: ?string;\n}\n\nexport type GraphQLFieldConfigArgumentMap = {\n  [argName: string]: GraphQLArgumentConfig;\n};\n\nexport type GraphQLArgumentConfig = {\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type GraphQLFieldConfigMap<TSource> = {\n  [fieldName: string]: GraphQLFieldConfig<TSource>;\n};\n\nexport type GraphQLFieldDefinition = {\n  name: string;\n  description: ?string;\n  type: GraphQLOutputType;\n  args: Array<GraphQLArgument>;\n  resolve?: GraphQLFieldResolveFn<*, *>;\n  deprecationReason?: ?string;\n}\n\nexport type GraphQLArgument = {\n  name: string;\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n};\n\nexport type GraphQLFieldDefinitionMap = {\n  [fieldName: string]: GraphQLFieldDefinition;\n};\n\n\n\n/**\n * Interface Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Interface type\n * is used to describe what types are possible, what fields are in common across\n * all types, as well as a function to determine which type is actually used\n * when the field is resolved.\n *\n * Example:\n *\n *     const EntityType = new GraphQLInterfaceType({\n *       name: 'Entity',\n *       fields: {\n *         name: { type: GraphQLString }\n *       }\n *     });\n *\n */\nexport class GraphQLInterfaceType {\n  name: string;\n  description: ?string;\n  resolveType: ?GraphQLTypeResolveFn;\n\n  _typeConfig: GraphQLInterfaceTypeConfig;\n  _fields: GraphQLFieldDefinitionMap;\n\n  constructor(config: GraphQLInterfaceTypeConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      invariant(\n        typeof config.resolveType === 'function',\n        `${this.name} must provide \"resolveType\" as a function.`\n      );\n    }\n    this.resolveType = config.resolveType;\n    this._typeConfig = config;\n  }\n\n  getFields(): GraphQLFieldDefinitionMap {\n    return this._fields ||\n      (this._fields = defineFieldMap(this, this._typeConfig.fields));\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLInterfaceTypeConfig = {\n  name: string,\n  fields: Thunk<GraphQLFieldConfigMap<mixed>>,\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: ?GraphQLTypeResolveFn,\n  description?: ?string\n};\n\n\n\n/**\n * Union Type Definition\n *\n * When a field can return one of a heterogeneous set of types, a Union type\n * is used to describe what types are possible as well as providing a function\n * to determine which type is actually used when the field is resolved.\n *\n * Example:\n *\n *     const PetType = new GraphQLUnionType({\n *       name: 'Pet',\n *       types: [ DogType, CatType ],\n *       resolveType(value) {\n *         if (value instanceof Dog) {\n *           return DogType;\n *         }\n *         if (value instanceof Cat) {\n *           return CatType;\n *         }\n *       }\n *     });\n *\n */\nexport class GraphQLUnionType {\n  name: string;\n  description: ?string;\n  resolveType: ?GraphQLTypeResolveFn;\n\n  _typeConfig: GraphQLUnionTypeConfig;\n  _types: Array<GraphQLObjectType>;\n  _possibleTypeNames: {[typeName: string]: boolean};\n\n  constructor(config: GraphQLUnionTypeConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    if (config.resolveType) {\n      invariant(\n        typeof config.resolveType === 'function',\n        `${this.name} must provide \"resolveType\" as a function.`\n      );\n    }\n    this.resolveType = config.resolveType;\n    invariant(\n      Array.isArray(config.types) && config.types.length > 0,\n      `Must provide Array of types for Union ${config.name}.`\n    );\n    config.types.forEach(type => {\n      invariant(\n        type instanceof GraphQLObjectType,\n        `${this.name} may only contain Object types, it cannot contain: ` +\n        `${String(type)}.`\n      );\n      if (typeof this.resolveType !== 'function') {\n        invariant(\n          typeof type.isTypeOf === 'function',\n          `Union Type ${this.name} does not provide a \"resolveType\" function ` +\n          `and possible Type ${type.name} does not provide a \"isTypeOf\" ` +\n          'function. There is no way to resolve this possible type ' +\n          'during execution.'\n        );\n      }\n    });\n    this._types = config.types;\n    this._typeConfig = config;\n  }\n\n  getTypes(): Array<GraphQLObjectType> {\n    return this._types;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type GraphQLUnionTypeConfig = {\n  name: string,\n  types: Array<GraphQLObjectType>,\n  /**\n   * Optionally provide a custom type resolver function. If one is not provided,\n   * the default implementation will call `isTypeOf` on each implementing\n   * Object type.\n   */\n  resolveType?: GraphQLTypeResolveFn;\n  description?: ?string;\n};\n\n\n\n/**\n * Enum Type Definition\n *\n * Some leaf values of requests and input values are Enums. GraphQL serializes\n * Enum values as strings, however internally Enums can be represented by any\n * kind of type, often integers.\n *\n * Example:\n *\n *     const RGBType = new GraphQLEnumType({\n *       name: 'RGB',\n *       values: {\n *         RED: { value: 0 },\n *         GREEN: { value: 1 },\n *         BLUE: { value: 2 }\n *       }\n *     });\n *\n * Note: If a value is not provided in a definition, the name of the enum value\n * will be used as its internal value.\n */\nexport class GraphQLEnumType/* <T> */ {\n  name: string;\n  description: ?string;\n\n  _enumConfig: GraphQLEnumTypeConfig/* <T> */;\n  _values: Array<GraphQLEnumValueDefinition/* <T> */>;\n  _valueLookup: Map<any/* T */, GraphQLEnumValueDefinition>;\n  _nameLookup: { [valueName: string]: GraphQLEnumValueDefinition };\n\n  constructor(config: GraphQLEnumTypeConfig/* <T> */) {\n    this.name = config.name;\n    assertValidName(config.name);\n    this.description = config.description;\n    this._values = defineEnumValues(this, config.values);\n    this._enumConfig = config;\n  }\n\n  getValues(): Array<GraphQLEnumValueDefinition/* <T> */> {\n    return this._values;\n  }\n\n  serialize(value: any/* T */): ?string {\n    const enumValue = this._getValueLookup().get(value);\n    return enumValue ? enumValue.name : null;\n  }\n\n  parseValue(value: mixed): ?any/* T */ {\n    if (typeof value === 'string') {\n      const enumValue = this._getNameLookup()[value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  }\n\n  parseLiteral(valueAST: Value): ?any/* T */ {\n    if (valueAST.kind === ENUM) {\n      const enumValue = this._getNameLookup()[valueAST.value];\n      if (enumValue) {\n        return enumValue.value;\n      }\n    }\n  }\n\n  _getValueLookup(): Map<any/* T */, GraphQLEnumValueDefinition> {\n    if (!this._valueLookup) {\n      const lookup = new Map();\n      this.getValues().forEach(value => {\n        lookup.set(value.value, value);\n      });\n      this._valueLookup = lookup;\n    }\n    return this._valueLookup;\n  }\n\n  _getNameLookup(): { [valueName: string]: GraphQLEnumValueDefinition } {\n    if (!this._nameLookup) {\n      const lookup = Object.create(null);\n      this.getValues().forEach(value => {\n        lookup[value.name] = value;\n      });\n      this._nameLookup = lookup;\n    }\n    return this._nameLookup;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nfunction defineEnumValues(\n  type: GraphQLEnumType,\n  valueMap: GraphQLEnumValueConfigMap/* <T> */\n): Array<GraphQLEnumValueDefinition/* <T> */> {\n  invariant(\n    isPlainObj(valueMap),\n    `${type.name} values must be an object with value names as keys.`\n  );\n  const valueNames = Object.keys(valueMap);\n  invariant(\n    valueNames.length > 0,\n    `${type.name} values must be an object with value names as keys.`\n  );\n  return valueNames.map(valueName => {\n    assertValidName(valueName);\n    const value = valueMap[valueName];\n    invariant(\n      isPlainObj(value),\n      `${type.name}.${valueName} must refer to an object with a \"value\" key ` +\n      `representing an internal value but got: ${String(value)}.`\n    );\n    invariant(\n      !value.hasOwnProperty('isDeprecated'),\n      `${type.name}.${valueName} should provide \"deprecationReason\" instead ` +\n      'of \"isDeprecated\".'\n    );\n    return {\n      name: valueName,\n      description: value.description,\n      deprecationReason: value.deprecationReason,\n      value: isNullish(value.value) ? valueName : value.value,\n    };\n  });\n}\n\nexport type GraphQLEnumTypeConfig/* <T> */ = {\n  name: string;\n  values: GraphQLEnumValueConfigMap/* <T> */;\n  description?: ?string;\n}\n\nexport type GraphQLEnumValueConfigMap/* <T> */ = {\n  [valueName: string]: GraphQLEnumValueConfig/* <T> */;\n};\n\nexport type GraphQLEnumValueConfig/* <T> */ = {\n  value?: any/* T */;\n  deprecationReason?: ?string;\n  description?: ?string;\n}\n\nexport type GraphQLEnumValueDefinition/* <T> */ = {\n  name: string;\n  description: ?string;\n  deprecationReason: ?string;\n  value: any/* T */;\n}\n\n\n\n/**\n * Input Object Type Definition\n *\n * An input object defines a structured collection of fields which may be\n * supplied to a field argument.\n *\n * Using `NonNull` will ensure that a value must be provided by the query\n *\n * Example:\n *\n *     const GeoPoint = new GraphQLInputObjectType({\n *       name: 'GeoPoint',\n *       fields: {\n *         lat: { type: new GraphQLNonNull(GraphQLFloat) },\n *         lon: { type: new GraphQLNonNull(GraphQLFloat) },\n *         alt: { type: GraphQLFloat, defaultValue: 0 },\n *       }\n *     });\n *\n */\nexport class GraphQLInputObjectType {\n  name: string;\n  description: ?string;\n\n  _typeConfig: InputObjectConfig;\n  _fields: InputObjectFieldMap;\n\n  constructor(config: InputObjectConfig) {\n    invariant(config.name, 'Type must be named.');\n    assertValidName(config.name);\n    this.name = config.name;\n    this.description = config.description;\n    this._typeConfig = config;\n  }\n\n  getFields(): InputObjectFieldMap {\n    return this._fields || (this._fields = this._defineFieldMap());\n  }\n\n  _defineFieldMap(): InputObjectFieldMap {\n    const fieldMap: any = resolveThunk(this._typeConfig.fields);\n    invariant(\n      isPlainObj(fieldMap),\n      `${this.name} fields must be an object with field names as keys or a ` +\n      'function which returns such an object.'\n    );\n    const fieldNames = Object.keys(fieldMap);\n    invariant(\n      fieldNames.length > 0,\n      `${this.name} fields must be an object with field names as keys or a ` +\n      'function which returns such an object.'\n    );\n    const resultFieldMap = {};\n    fieldNames.forEach(fieldName => {\n      assertValidName(fieldName);\n      const field = {\n        ...fieldMap[fieldName],\n        name: fieldName\n      };\n      invariant(\n        isInputType(field.type),\n        `${this.name}.${fieldName} field type must be Input Type but ` +\n        `got: ${String(field.type)}.`\n      );\n      resultFieldMap[fieldName] = field;\n    });\n    return resultFieldMap;\n  }\n\n  toString(): string {\n    return this.name;\n  }\n}\n\nexport type InputObjectConfig = {\n  name: string;\n  fields: Thunk<InputObjectConfigFieldMap>;\n  description?: ?string;\n}\n\nexport type InputObjectFieldConfig = {\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type InputObjectConfigFieldMap = {\n  [fieldName: string]: InputObjectFieldConfig;\n};\n\nexport type InputObjectField = {\n  name: string;\n  type: GraphQLInputType;\n  defaultValue?: mixed;\n  description?: ?string;\n}\n\nexport type InputObjectFieldMap = {\n  [fieldName: string]: InputObjectField;\n};\n\n\n\n/**\n * List Modifier\n *\n * A list is a kind of type marker, a wrapping type which points to another\n * type. Lists are often created within the context of defining the fields of\n * an object type.\n *\n * Example:\n *\n *     const PersonType = new GraphQLObjectType({\n *       name: 'Person',\n *       fields: () => ({\n *         parents: { type: new GraphQLList(Person) },\n *         children: { type: new GraphQLList(Person) },\n *       })\n *     })\n *\n */\nexport class GraphQLList<T: GraphQLType> {\n  ofType: T;\n\n  constructor(type: T) {\n    invariant(\n      isType(type),\n      `Can only create List of a GraphQLType but got: ${String(type)}.`\n    );\n    this.ofType = type;\n  }\n\n  toString(): string {\n    return '[' + String(this.ofType) + ']';\n  }\n}\n\n\n/**\n * Non-Null Modifier\n *\n * A non-null is a kind of type marker, a wrapping type which points to another\n * type. Non-null types enforce that their values are never null and can ensure\n * an error is raised if this ever occurs during a request. It is useful for\n * fields which you can make a strong guarantee on non-nullability, for example\n * usually the id field of a database row will never be null.\n *\n * Example:\n *\n *     const RowType = new GraphQLObjectType({\n *       name: 'Row',\n *       fields: () => ({\n *         id: { type: new GraphQLNonNull(GraphQLString) },\n *       })\n *     })\n *\n * Note: the enforcement of non-nullability occurs within the executor.\n */\nexport class GraphQLNonNull<T: GraphQLNullableType> {\n  ofType: T;\n\n  constructor(type: T) {\n    invariant(\n      isType(type) && !(type instanceof GraphQLNonNull),\n      'Can only create NonNull of a Nullable GraphQLType but got: ' +\n      `${String(type)}.`\n    );\n    this.ofType = type;\n  }\n\n  toString(): string {\n    return this.ofType.toString() + '!';\n  }\n}\n\nexport type {\n  OperationDefinition,\n  Field,\n  FragmentDefinition,\n  Value\n};\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}