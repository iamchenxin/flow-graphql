{"version":3,"sources":["validation/rules/OverlappingFieldsCanBeMerged.js"],"names":[],"mappings":"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","file":"validation/rules/OverlappingFieldsCanBeMerged.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { ValidationContext } from '../index';\nimport { GraphQLError } from '../../error';\nimport find from '../../jsutils/find';\nimport type {\n  SelectionSet,\n  Field,\n  Argument,\n  FragmentDefinition,\n} from '../../language/ast';\nimport { FIELD, INLINE_FRAGMENT, FRAGMENT_SPREAD } from '../../language/kinds';\nimport { print } from '../../language/printer';\nimport {\n  getNamedType,\n  isLeafType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n} from '../../type/definition';\nimport type {\n  GraphQLNamedType,\n  GraphQLOutputType,\n  GraphQLCompositeType,\n  GraphQLFieldDefinition\n} from '../../type/definition';\nimport { typeFromAST } from '../../utilities/typeFromAST';\n\n\nexport function fieldsConflictMessage(\n  responseName: string,\n  reason: ConflictReasonMessage\n): string {\n  return `Fields \"${responseName}\" conflict because ${reasonMessage(reason)}` +\n    '. Use different aliases on the fields to fetch both if this was ' +\n    'intentional.';\n}\n\nfunction reasonMessage(reason: ConflictReasonMessage): string {\n  if (Array.isArray(reason)) {\n    return reason.map(([ responseName, subreason ]) =>\n      `subfields \"${responseName}\" conflict because ${reasonMessage(subreason)}`\n    ).join(' and ');\n  }\n  return reason;\n}\n\n/**\n * Overlapping fields can be merged\n *\n * A selection set is only valid if all fields (including spreading any\n * fragments) either correspond to distinct response names or can be merged\n * without ambiguity.\n */\nexport function OverlappingFieldsCanBeMerged(context: ValidationContext): any {\n  // A memoization for when two fragments are compared \"between\" each other for\n  // conflicts. Two fragments may be compared many times, so memoizing this can\n  // dramatically improve the performance of this validator.\n  const comparedFragments = new PairSet();\n\n  // A cache for the \"field map\" and list of fragment names found in any given\n  // selection set. Selection sets may be asked for this information multiple\n  // times, so this improves the performance of this validator.\n  const cachedFieldsAndFragmentNames = new Map();\n\n  return {\n    SelectionSet(selectionSet) {\n      const conflicts = findConflictsWithinSelectionSet(\n        context,\n        cachedFieldsAndFragmentNames,\n        comparedFragments,\n        context.getParentType(),\n        selectionSet\n      );\n      conflicts.forEach(\n        ([ [ responseName, reason ], fields1, fields2 ]) =>\n          context.reportError(new GraphQLError(\n            fieldsConflictMessage(responseName, reason),\n            fields1.concat(fields2)\n          ))\n      );\n    }\n  };\n}\n\ntype Conflict = [ ConflictReason, Array<Field>, Array<Field> ];\n// Field name and reason.\ntype ConflictReason = [ string, ConflictReasonMessage ];\n// Reason is a string, or a nested list of conflicts.\ntype ConflictReasonMessage = string | Array<ConflictReason>;\n// Tuple defining an AST in a context\ntype AstAndDef = [ GraphQLCompositeType, Field, ?GraphQLFieldDefinition ];\n// Map of array of those.\ntype AstAndDefCollection = { [key: string]: Array<AstAndDef> };\n\n/**\n * Algorithm:\n *\n * Conflicts occur when two fields exist in a query which will produce the same\n * response name, but represent differing values, thus creating a conflict.\n * The algorithm below finds all conflicts via making a series of comparisons\n * between fields. In order to compare as few fields as possible, this makes\n * a series of comparisons \"within\" sets of fields and \"between\" sets of fields.\n *\n * Given any selection set, a collection produces both a set of fields by\n * also including all inline fragments, as well as a list of fragments\n * referenced by fragment spreads.\n *\n * A) Each selection set represented in the document first compares \"within\" its\n * collected set of fields, finding any conflicts between every pair of\n * overlapping fields.\n * Note: This is the *only time* that a the fields \"within\" a set are compared\n * to each other. After this only fields \"between\" sets are compared.\n *\n * B) Also, if any fragment is referenced in a selection set, then a\n * comparison is made \"between\" the original set of fields and the\n * referenced fragment.\n *\n * C) Also, if multiple fragments are referenced, then comparisons\n * are made \"between\" each referenced fragment.\n *\n * D) When comparing \"between\" a set of fields and a referenced fragment, first\n * a comparison is made between each field in the original set of fields and\n * each field in the the referenced set of fields.\n *\n * E) Also, if any fragment is referenced in the referenced selection set,\n * then a comparison is made \"between\" the original set of fields and the\n * referenced fragment (recursively referring to step D).\n *\n * F) When comparing \"between\" two fragments, first a comparison is made between\n * each field in the first referenced set of fields and each field in the the\n * second referenced set of fields.\n *\n * G) Also, any fragments referenced by the first must be compared to the\n * second, and any fragments referenced by the second must be compared to the\n * first (recursively referring to step F).\n *\n * H) When comparing two fields, if both have selection sets, then a comparison\n * is made \"between\" both selection sets, first comparing the set of fields in\n * the first selection set with the set of fields in the second.\n *\n * I) Also, if any fragment is referenced in either selection set, then a\n * comparison is made \"between\" the other set of fields and the\n * referenced fragment.\n *\n * J) Also, if two fragments are referenced in both selection sets, then a\n * comparison is made \"between\" the two fragments.\n *\n */\n\n// Find all conflicts found \"within\" a selection set, including those found\n// via spreading in fragments. Called when visiting each SelectionSet in the\n// GraphQL Document.\nfunction findConflictsWithinSelectionSet(\n  context: ValidationContext,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  parentType: ?GraphQLNamedType,\n  selectionSet: SelectionSet\n): Array<Conflict> {\n  const conflicts = [];\n\n  const [ fieldMap, fragmentNames ] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType,\n    selectionSet\n  );\n\n  // (A) Find find all conflicts \"within\" the fields of this selection set.\n  // Note: this is the *only place* `collectConflictsWithin` is called.\n  collectConflictsWithin(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragments,\n    fieldMap\n  );\n\n  // (B) Then collect conflicts between these fields and those represented by\n  // each spread fragment name found.\n  for (let i = 0; i < fragmentNames.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      false,\n      fieldMap,\n      fragmentNames[i]\n    );\n    // (C) Then compare this fragment with all other fragments found in this\n    // selection set to collect conflicts between fragments spread together.\n    // This compares each item in the list of fragment names to every other item\n    // in that same list (except for itself).\n    for (let j = i + 1; j < fragmentNames.length; j++) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragments,\n        false,\n        fragmentNames[i],\n        fragmentNames[j]\n      );\n    }\n  }\n  return conflicts;\n}\n\n// Collect all conflicts found between a set of fields and a fragment reference\n// including via spreading in any nested fragments.\nfunction collectConflictsBetweenFieldsAndFragment(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  areMutuallyExclusive: boolean,\n  fieldMap: AstAndDefCollection,\n  fragmentName: string\n): void {\n  const fragment = context.getFragment(fragmentName);\n  if (!fragment) {\n    return;\n  }\n\n  const [ fieldMap2, fragmentNames2 ] = getReferencedFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragment\n  );\n\n  // (D) First collect any conflicts between the provided collection of fields\n  // and the collection of fields represented by the given fragment.\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragments,\n    areMutuallyExclusive,\n    fieldMap,\n    fieldMap2\n  );\n\n  // (E) Then collect any conflicts between the provided collection of fields\n  // and any fragment names found in the given fragment.\n  for (let i = 0; i < fragmentNames2.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      fieldMap,\n      fragmentNames2[i]\n    );\n  }\n}\n\n// Collect all conflicts found between two fragments, including via spreading in\n// any nested fragments.\nfunction collectConflictsBetweenFragments(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  areMutuallyExclusive: boolean,\n  fragmentName1: string,\n  fragmentName2: string\n): void {\n  const fragment1 = context.getFragment(fragmentName1);\n  const fragment2 = context.getFragment(fragmentName2);\n  if (!fragment1 || !fragment2) {\n    return;\n  }\n\n  // No need to compare a fragment to itself.\n  if (fragment1 === fragment2) {\n    return;\n  }\n\n  // Memoize so two fragments are not compared for conflicts more than once.\n  if (\n    comparedFragments.has(fragmentName1, fragmentName2, areMutuallyExclusive)\n  ) {\n    return;\n  }\n  comparedFragments.add(fragmentName1, fragmentName2, areMutuallyExclusive);\n\n  const [ fieldMap1, fragmentNames1 ] = getReferencedFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragment1\n  );\n  const [ fieldMap2, fragmentNames2 ] = getReferencedFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    fragment2\n  );\n\n  // (F) First, collect all conflicts between these two collections of fields\n  // (not including any nested fragments).\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragments,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2\n  );\n\n  // (G) Then collect conflicts between the first fragment and any nested\n  // fragments spread in the second fragment.\n  for (let j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      fragmentName1,\n      fragmentNames2[j]\n    );\n  }\n\n  // (G) Then collect conflicts between the second fragment and any nested\n  // fragments spread in the first fragment.\n  for (let i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFragments(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      fragmentNames1[i],\n      fragmentName2\n    );\n  }\n}\n\n// Find all conflicts found between two selection sets, including those found\n// via spreading in fragments. Called when determining if conflicts exist\n// between the sub-fields of two overlapping fields.\nfunction findConflictsBetweenSubSelectionSets(\n  context: ValidationContext,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  areMutuallyExclusive: boolean,\n  parentType1: ?GraphQLNamedType,\n  selectionSet1: SelectionSet,\n  parentType2: ?GraphQLNamedType,\n  selectionSet2: SelectionSet\n): Array<Conflict> {\n  const conflicts = [];\n\n  const [ fieldMap1, fragmentNames1 ] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType1,\n    selectionSet1\n  );\n  const [ fieldMap2, fragmentNames2 ] = getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    parentType2,\n    selectionSet2\n  );\n\n  // (H) First, collect all conflicts between these two collections of field.\n  collectConflictsBetween(\n    context,\n    conflicts,\n    cachedFieldsAndFragmentNames,\n    comparedFragments,\n    areMutuallyExclusive,\n    fieldMap1,\n    fieldMap2\n  );\n\n  // (I) Then collect conflicts between the first collection of fields and\n  // those referenced by each fragment name associated with the second.\n  for (let j = 0; j < fragmentNames2.length; j++) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      fieldMap1,\n      fragmentNames2[j]\n    );\n  }\n\n  // (I) Then collect conflicts between the second collection of fields and\n  // those referenced by each fragment name associated with the first.\n  for (let i = 0; i < fragmentNames1.length; i++) {\n    collectConflictsBetweenFieldsAndFragment(\n      context,\n      conflicts,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      fieldMap2,\n      fragmentNames1[i]\n    );\n  }\n\n  // (J) Also collect conflicts between any fragment names by the first and\n  // fragment names by the second. This compares each item in the first set of\n  // names to each item in the second set of names.\n  for (let i = 0; i < fragmentNames1.length; i++) {\n    for (let j = 0; j < fragmentNames2.length; j++) {\n      collectConflictsBetweenFragments(\n        context,\n        conflicts,\n        cachedFieldsAndFragmentNames,\n        comparedFragments,\n        areMutuallyExclusive,\n        fragmentNames1[i],\n        fragmentNames2[j]\n      );\n    }\n  }\n  return conflicts;\n}\n\n// Collect all Conflicts \"within\" one collection of fields.\nfunction collectConflictsWithin(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  fieldMap: AstAndDefCollection\n): void {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For every response name, if there are multiple fields, they\n  // must be compared to find a potential conflict.\n  Object.keys(fieldMap).forEach(responseName => {\n    const fields = fieldMap[responseName];\n    // This compares every field in the list to every other field in this list\n    // (except to itself). If the list only has one item, nothing needs to\n    // be compared.\n    if (fields.length > 1) {\n      for (let i = 0; i < fields.length; i++) {\n        for (let j = i + 1; j < fields.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragments,\n            false, // within one collection is never mutually exclusive\n            responseName,\n            fields[i],\n            fields[j]\n          );\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Collect all Conflicts between two collections of fields. This is similar to,\n// but different from the `collectConflictsWithin` function above. This check\n// assumes that `collectConflictsWithin` has already been called on each\n// provided collection of fields. This is true because this validator traverses\n// each individual selection set.\nfunction collectConflictsBetween(\n  context: ValidationContext,\n  conflicts: Array<Conflict>,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  parentFieldsAreMutuallyExclusive: boolean,\n  fieldMap1: AstAndDefCollection,\n  fieldMap2: AstAndDefCollection\n): void {\n  // A field map is a keyed collection, where each key represents a response\n  // name and the value at that key is a list of all fields which provide that\n  // response name. For any response name which appears in both provided field\n  // maps, each field from the first field map must be compared to every field\n  // in the second field map to find potential conflicts.\n  Object.keys(fieldMap1).forEach(responseName => {\n    const fields2 = fieldMap2[responseName];\n    if (fields2) {\n      const fields1 = fieldMap1[responseName];\n      for (let i = 0; i < fields1.length; i++) {\n        for (let j = 0; j < fields2.length; j++) {\n          const conflict = findConflict(\n            context,\n            cachedFieldsAndFragmentNames,\n            comparedFragments,\n            parentFieldsAreMutuallyExclusive,\n            responseName,\n            fields1[i],\n            fields2[j]\n          );\n          if (conflict) {\n            conflicts.push(conflict);\n          }\n        }\n      }\n    }\n  });\n}\n\n// Determines if there is a conflict between two particular fields, including\n// comparing their sub-fields.\nfunction findConflict(\n  context: ValidationContext,\n  cachedFieldsAndFragmentNames,\n  comparedFragments: PairSet,\n  parentFieldsAreMutuallyExclusive: boolean,\n  responseName: string,\n  field1: AstAndDef,\n  field2: AstAndDef\n): ?Conflict {\n  const [ parentType1, ast1, def1 ] = field1;\n  const [ parentType2, ast2, def2 ] = field2;\n\n  // If it is known that two fields could not possibly apply at the same\n  // time, due to the parent types, then it is safe to permit them to diverge\n  // in aliased field or arguments used as they will not present any ambiguity\n  // by differing.\n  // It is known that two parent types could never overlap if they are\n  // different Object types. Interface or Union types might overlap - if not\n  // in the current state of the schema, then perhaps in some future version,\n  // thus may not safely diverge.\n  const areMutuallyExclusive =\n    parentFieldsAreMutuallyExclusive ||\n    parentType1 !== parentType2 &&\n    parentType1 instanceof GraphQLObjectType &&\n    parentType2 instanceof GraphQLObjectType;\n\n  // The return type for each field.\n  const type1 = def1 && def1.type;\n  const type2 = def2 && def2.type;\n\n  if (!areMutuallyExclusive) {\n    // Two aliases must refer to the same field.\n    const name1 = ast1.name.value;\n    const name2 = ast2.name.value;\n    if (name1 !== name2) {\n      return [\n        [ responseName, `${name1} and ${name2} are different fields` ],\n        [ ast1 ],\n        [ ast2 ]\n      ];\n    }\n\n    // Two field calls must have the same arguments.\n    if (!sameArguments(ast1.arguments || [], ast2.arguments || [])) {\n      return [\n        [ responseName, 'they have differing arguments' ],\n        [ ast1 ],\n        [ ast2 ]\n      ];\n    }\n  }\n\n  if (type1 && type2 && doTypesConflict(type1, type2)) {\n    return [\n      [ responseName,\n        `they return conflicting types ${String(type1)} and ${String(type2)}` ],\n      [ ast1 ],\n      [ ast2 ]\n    ];\n  }\n\n  // Collect and compare sub-fields. Use the same \"visited fragment names\" list\n  // for both collections so fields in a fragment reference are never\n  // compared to themselves.\n  const selectionSet1 = ast1.selectionSet;\n  const selectionSet2 = ast2.selectionSet;\n  if (selectionSet1 && selectionSet2) {\n    const conflicts = findConflictsBetweenSubSelectionSets(\n      context,\n      cachedFieldsAndFragmentNames,\n      comparedFragments,\n      areMutuallyExclusive,\n      getNamedType(type1),\n      selectionSet1,\n      getNamedType(type2),\n      selectionSet2\n    );\n    return subfieldConflicts(conflicts, responseName, ast1, ast2);\n  }\n}\n\nfunction sameArguments(\n  arguments1: Array<Argument>,\n  arguments2: Array<Argument>\n): boolean {\n  if (arguments1.length !== arguments2.length) {\n    return false;\n  }\n  return arguments1.every(argument1 => {\n    const argument2 = find(\n      arguments2,\n      argument => argument.name.value === argument1.name.value\n    );\n    if (!argument2) {\n      return false;\n    }\n    return sameValue(argument1.value, argument2.value);\n  });\n}\n\nfunction sameValue(value1, value2) {\n  return (!value1 && !value2) || print(value1) === print(value2);\n}\n\n// Two types conflict if both types could not apply to a value simultaneously.\n// Composite types are ignored as their individual field types will be compared\n// later recursively. However List and Non-Null types must match.\nfunction doTypesConflict(\n  type1: GraphQLOutputType,\n  type2: GraphQLOutputType\n): boolean {\n  if (type1 instanceof GraphQLList) {\n    return type2 instanceof GraphQLList ?\n      doTypesConflict(type1.ofType, type2.ofType) :\n      true;\n  }\n  if (type2 instanceof GraphQLList) {\n    return type1 instanceof GraphQLList ?\n      doTypesConflict(type1.ofType, type2.ofType) :\n      true;\n  }\n  if (type1 instanceof GraphQLNonNull) {\n    return type2 instanceof GraphQLNonNull ?\n      doTypesConflict(type1.ofType, type2.ofType) :\n      true;\n  }\n  if (type2 instanceof GraphQLNonNull) {\n    return type1 instanceof GraphQLNonNull ?\n      doTypesConflict(type1.ofType, type2.ofType) :\n      true;\n  }\n  if (isLeafType(type1) || isLeafType(type2)) {\n    return type1 !== type2;\n  }\n  return false;\n}\n\n// Given a selection set, return the collection of fields (a mapping of response\n// name to field ASTs and definitions) as well as a list of fragment names\n// referenced via fragment spreads.\nfunction getFieldsAndFragmentNames(\n  context: ValidationContext,\n  cachedFieldsAndFragmentNames,\n  parentType: ?GraphQLNamedType,\n  selectionSet: SelectionSet\n): [ AstAndDefCollection, Array<string> ] {\n  let cached = cachedFieldsAndFragmentNames.get(selectionSet);\n  if (!cached) {\n    const astAndDefs = {};\n    const fragmentNames = {};\n    _collectFieldsAndFragmentNames(\n      context,\n      parentType,\n      selectionSet,\n      astAndDefs,\n      fragmentNames\n    );\n    cached = [ astAndDefs, Object.keys(fragmentNames) ];\n    cachedFieldsAndFragmentNames.set(selectionSet, cached);\n  }\n  return cached;\n}\n\n// Given a reference to a fragment, return the represented collection of fields\n// as well as a list of nested fragment names referenced via fragment spreads.\nfunction getReferencedFieldsAndFragmentNames(\n  context: ValidationContext,\n  cachedFieldsAndFragmentNames,\n  fragment: FragmentDefinition\n) {\n  // Short-circuit building a type from the AST if possible.\n  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);\n  if (cached) {\n    return cached;\n  }\n\n  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);\n  return getFieldsAndFragmentNames(\n    context,\n    cachedFieldsAndFragmentNames,\n    ((fragmentType: any): GraphQLNamedType),\n    fragment.selectionSet\n  );\n}\n\nfunction _collectFieldsAndFragmentNames(\n  context: ValidationContext,\n  parentType: ?GraphQLNamedType,\n  selectionSet: SelectionSet,\n  astAndDefs,\n  fragmentNames\n): void {\n  for (let i = 0; i < selectionSet.selections.length; i++) {\n    const selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case FIELD:\n        const fieldName = selection.name.value;\n        let fieldDef;\n        if (parentType instanceof GraphQLObjectType ||\n            parentType instanceof GraphQLInterfaceType) {\n          fieldDef = parentType.getFields()[fieldName];\n        }\n        const responseName =\n          selection.alias ? selection.alias.value : fieldName;\n        if (!astAndDefs[responseName]) {\n          astAndDefs[responseName] = [];\n        }\n        astAndDefs[responseName].push([ parentType, selection, fieldDef ]);\n        break;\n      case FRAGMENT_SPREAD:\n        fragmentNames[selection.name.value] = true;\n        break;\n      case INLINE_FRAGMENT:\n        const typeCondition = selection.typeCondition;\n        const inlineFragmentType = typeCondition ?\n          typeFromAST(context.getSchema(), selection.typeCondition) :\n          parentType;\n        _collectFieldsAndFragmentNames(\n          context,\n          ((inlineFragmentType: any): GraphQLNamedType),\n          selection.selectionSet,\n          astAndDefs,\n          fragmentNames\n        );\n        break;\n    }\n  }\n}\n\n// Given a series of Conflicts which occurred between two sub-fields, generate\n// a single Conflict.\nfunction subfieldConflicts(\n  conflicts: Array<Conflict>,\n  responseName: string,\n  ast1: Field,\n  ast2: Field\n): ?Conflict {\n  if (conflicts.length > 0) {\n    return [\n      [ responseName, conflicts.map(([ reason ]) => reason) ],\n      conflicts.reduce(\n        (allFields, [ , fields1 ]) => allFields.concat(fields1),\n        [ ast1 ]\n      ),\n      conflicts.reduce(\n        (allFields, [ , , fields2 ]) => allFields.concat(fields2),\n        [ ast2 ]\n      )\n    ];\n  }\n}\n\n/**\n * A way to keep track of pairs of things when the ordering of the pair does\n * not matter. We do this by maintaining a sort of double adjacency sets.\n */\nclass PairSet {\n  _data: {[a: string]: {[b: string]: boolean}};\n\n  constructor() {\n    this._data = Object.create(null);\n  }\n\n  has(a: string, b: string, areMutuallyExclusive: boolean) {\n    const first = this._data[a];\n    const result = first && first[b];\n    if (result === undefined) {\n      return false;\n    }\n    // areMutuallyExclusive being false is a superset of being true,\n    // hence if we want to know if this PairSet \"has\" these two with no\n    // exclusivity, we have to ensure it was added as such.\n    if (areMutuallyExclusive === false) {\n      return result === false;\n    }\n    return true;\n  }\n\n  add(a: string, b: string, areMutuallyExclusive: boolean) {\n    _pairSetAdd(this._data, a, b, areMutuallyExclusive);\n    _pairSetAdd(this._data, b, a, areMutuallyExclusive);\n  }\n}\n\nfunction _pairSetAdd(data, a, b, areMutuallyExclusive) {\n  let map = data[a];\n  if (!map) {\n    map = Object.create(null);\n    data[a] = map;\n  }\n  map[b] = areMutuallyExclusive;\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}