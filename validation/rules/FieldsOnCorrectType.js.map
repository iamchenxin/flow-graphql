{"version":3,"sources":["validation/rules/FieldsOnCorrectType.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;QAwBgB;QAsBA;;AAnChB;;AACA;;;;AACA;;;;AAIA;;;;AAOO,SAAS,qBAAT,CACL,SADK,EAEL,IAFK,EAGL,kBAHK,EAIL,mBAJK,EAKG;AACR,MAAI,mCAAiC,4BAAuB,WAAxD,CADI;AAER,MAAI,mBAAmB,MAAnB,KAA8B,CAA9B,EAAiC;AACnC,QAAM,cAAc,4BAAa,kBAAb,CAAd,CAD6B;AAEnC,+DAAyD,iBAAzD,CAFmC;GAArC,MAGO,IAAI,oBAAoB,MAApB,KAA+B,CAA/B,EAAkC;AAC3C,kCAA4B,4BAAa,mBAAb,OAA5B,CAD2C;GAAtC;AAGP,SAAO,OAAP,CARQ;CALH;;;;;;;;AAsBA,SAAS,mBAAT,CAA6B,OAA7B,EAA8D;AACnE,SAAO;AACL,0BAAM,MAAa;AACjB,UAAM,OAAO,QAAQ,aAAR,EAAP,CADW;AAEjB,UAAI,IAAJ,EAAU;AACR,YAAM,WAAW,QAAQ,WAAR,EAAX,CADE;AAER,YAAI,CAAC,QAAD,EAAW;;AAEb,cAAM,SAAS,QAAQ,SAAR,EAAT,CAFO;AAGb,cAAM,YAAY,KAAK,IAAL,CAAU,KAAV;;AAHL,cAKP,qBACJ,sBAAsB,MAAtB,EAA8B,IAA9B,EAAoC,SAApC,CADI;;AALO,cAQP,sBAAsB,mBAAmB,MAAnB,KAA8B,CAA9B,GAC1B,EAD0B,GAE1B,uBAAuB,MAAvB,EAA+B,IAA/B,EAAqC,SAArC,CAF0B;;;AARf,iBAab,CAAQ,WAAR,CAAoB,wBAClB,sBACE,SADF,EAEE,KAAK,IAAL,EACA,kBAHF,EAIE,mBAJF,CADkB,EAOlB,CAAE,IAAF,CAPkB,CAApB,EAba;SAAf;OAFF;KAHG;GAAP,CADmE;CAA9D;;;;;;;;AAwCP,SAAS,qBAAT,CACE,MADF,EAEE,IAFF,EAGE,SAHF,EAIiB;AACf,MAAI,oDACA,4CADA,EACkC;;AACpC,UAAM,uBAAuB,EAAvB;AACN,UAAM,sBAAsB,OAAO,MAAP,CAAc,IAAd,CAAtB;AACN,aAAO,gBAAP,CAAwB,IAAxB,EAA8B,OAA9B,CAAsC,wBAAgB;AACpD,YAAI,CAAC,aAAa,SAAb,GAAyB,SAAzB,CAAD,EAAsC;AACxC,iBADwC;SAA1C;;AADoD,4BAKpD,CAAqB,IAArB,CAA0B,aAAa,IAAb,CAA1B,CALoD;AAMpD,qBAAa,aAAb,GAA6B,OAA7B,CAAqC,6BAAqB;AACxD,cAAI,CAAC,kBAAkB,SAAlB,GAA8B,SAA9B,CAAD,EAA2C;AAC7C,mBAD6C;WAA/C;;AADwD,6BAKxD,CAAoB,kBAAkB,IAAlB,CAApB,GACE,CAAC,oBAAoB,kBAAkB,IAAlB,CAApB,IAA+C,CAA/C,CAAD,GAAqD,CAArD,CANsD;SAArB,CAArC,CANoD;OAAhB,CAAtC;;;AAiBA,UAAM,0BAA0B,OAAO,IAAP,CAAY,mBAAZ,EAC7B,IAD6B,CACxB,UAAC,CAAD,EAAI,CAAJ;eAAU,oBAAoB,CAApB,IAAyB,oBAAoB,CAApB,CAAzB;OAAV,CADF;;;AAIN;WAAO,wBAAwB,MAAxB,CAA+B,oBAA/B;OAAP;QAxBoC;;;GADtC;;;AADe,SA8BR,EAAP,CA9Be;CAJjB;;;;;;AAyCA,SAAS,sBAAT,CACE,MADF,EAEE,IAFF,EAGE,SAHF,EAIiB;AACf,MAAI,iDACA,gDADA,EACsC;AACxC,QAAM,qBAAqB,OAAO,IAAP,CAAY,KAAK,SAAL,EAAZ,CAArB,CADkC;AAExC,WAAO,8BAAe,SAAf,EAA0B,kBAA1B,CAAP,CAFwC;GAD1C;;AADe,SAOR,EAAP,CAPe;CAJjB","file":"validation/rules/FieldsOnCorrectType.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { ValidationContext } from '../index';\nimport { GraphQLError } from '../../error';\nimport suggestionList from '../../jsutils/suggestionList';\nimport quotedOrList from '../../jsutils/quotedOrList';\nimport type { Field } from '../../language/ast';\nimport type { GraphQLSchema } from '../../type/schema';\nimport type { GraphQLOutputType } from '../../type/definition';\nimport {\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n} from '../../type/definition';\n\n\nexport function undefinedFieldMessage(\n  fieldName: string,\n  type: string,\n  suggestedTypeNames: Array<string>,\n  suggestedFieldNames: Array<string>\n): string {\n  let message = `Cannot query field \"${fieldName}\" on type \"${type}\".`;\n  if (suggestedTypeNames.length !== 0) {\n    const suggestions = quotedOrList(suggestedTypeNames);\n    message += ` Did you mean to use an inline fragment on ${suggestions}?`;\n  } else if (suggestedFieldNames.length !== 0) {\n    message += ` Did you mean ${quotedOrList(suggestedFieldNames)}?`;\n  }\n  return message;\n}\n\n/**\n * Fields on correct type\n *\n * A GraphQL document is only valid if all fields selected are defined by the\n * parent type, or are an allowed meta field such as __typenamme\n */\nexport function FieldsOnCorrectType(context: ValidationContext): any {\n  return {\n    Field(node: Field) {\n      const type = context.getParentType();\n      if (type) {\n        const fieldDef = context.getFieldDef();\n        if (!fieldDef) {\n          // This field doesn't exist, lets look for suggestions.\n          const schema = context.getSchema();\n          const fieldName = node.name.value;\n          // First determine if there are any suggested types to condition on.\n          const suggestedTypeNames =\n            getSuggestedTypeNames(schema, type, fieldName);\n          // If there are no suggested types, then perhaps this was a typo?\n          const suggestedFieldNames = suggestedTypeNames.length !== 0 ?\n            [] :\n            getSuggestedFieldNames(schema, type, fieldName);\n\n          // Report an error, including helpful suggestions.\n          context.reportError(new GraphQLError(\n            undefinedFieldMessage(\n              fieldName,\n              type.name,\n              suggestedTypeNames,\n              suggestedFieldNames\n            ),\n            [ node ]\n          ));\n        }\n      }\n    }\n  };\n}\n\n/**\n * Go through all of the implementations of type, as well as the interfaces\n * that they implement. If any of those types include the provided field,\n * suggest them, sorted by how often the type is referenced,  starting\n * with Interfaces.\n */\nfunction getSuggestedTypeNames(\n  schema: GraphQLSchema,\n  type: GraphQLOutputType,\n  fieldName: string\n): Array<string> {\n  if (type instanceof GraphQLInterfaceType ||\n      type instanceof GraphQLUnionType) {\n    const suggestedObjectTypes = [];\n    const interfaceUsageCount = Object.create(null);\n    schema.getPossibleTypes(type).forEach(possibleType => {\n      if (!possibleType.getFields()[fieldName]) {\n        return;\n      }\n      // This object type defines this field.\n      suggestedObjectTypes.push(possibleType.name);\n      possibleType.getInterfaces().forEach(possibleInterface => {\n        if (!possibleInterface.getFields()[fieldName]) {\n          return;\n        }\n        // This interface type defines this field.\n        interfaceUsageCount[possibleInterface.name] =\n          (interfaceUsageCount[possibleInterface.name] || 0) + 1;\n      });\n    });\n\n    // Suggest interface types based on how common they are.\n    const suggestedInterfaceTypes = Object.keys(interfaceUsageCount)\n      .sort((a, b) => interfaceUsageCount[b] - interfaceUsageCount[a]);\n\n    // Suggest both interface and object types.\n    return suggestedInterfaceTypes.concat(suggestedObjectTypes);\n  }\n\n  // Otherwise, must be an Object type, which does not have possible fields.\n  return [];\n}\n\n/**\n * For the field name provided, determine if there are any similar field names\n * that may be the result of a typo.\n */\nfunction getSuggestedFieldNames(\n  schema: GraphQLSchema,\n  type: GraphQLOutputType,\n  fieldName: string\n): Array<string> {\n  if (type instanceof GraphQLObjectType ||\n      type instanceof GraphQLInterfaceType) {\n    const possibleFieldNames = Object.keys(type.getFields());\n    return suggestionList(fieldName, possibleFieldNames);\n  }\n  // Otherwise, must be a Union type, which does not define fields.\n  return [];\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}