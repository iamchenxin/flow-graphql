{"version":3,"sources":["validation/rules/PossibleFragmentSpreads.js"],"names":[],"mappings":";;;;;QAiBgB;QASA;QAeA;;AA9BhB;;AACA;;AACA;;;;;;;;;;;AAIO,SAAS,6BAAT,CACL,QADK,EAEL,UAFK,EAGL,QAHK,EAIG;AACR,SAAO,eAAa,mDAAb,eACI,0CAAqC,gBADzC,CADC;CAJH;;AASA,SAAS,iCAAT,CACL,UADK,EAEL,QAFK,EAGG;AACR,SAAO,8DACI,0CAAqC,gBADzC,CADC;CAHH;;;;;;;;;AAeA,SAAS,uBAAT,CAAiC,OAAjC,EAAkE;AACvE,SAAO;AACL,4CAAe,MAAM;AACnB,UAAM,WAAW,QAAQ,OAAR,EAAX,CADa;AAEnB,UAAM,aAAa,QAAQ,aAAR,EAAb,CAFa;AAGnB,UAAI,YACA,UADA,IAEA,CAAC,qCAAe,QAAQ,SAAR,EAAf,EAAoC,QAApC,EAA8C,UAA9C,CAAD,EAA4D;AAC9D,gBAAQ,WAAR,CAAoB,wBAClB,kCAAkC,UAAlC,EAA8C,QAA9C,CADkB,EAElB,CAAE,IAAF,CAFkB,CAApB,EAD8D;OAFhE;KAJG;AAaL,4CAAe,MAAM;AACnB,UAAM,WAAW,KAAK,IAAL,CAAU,KAAV,CADE;AAEnB,UAAM,WAAW,gBAAgB,OAAhB,EAAyB,QAAzB,CAAX,CAFa;AAGnB,UAAM,aAAa,QAAQ,aAAR,EAAb,CAHa;AAInB,UAAI,YACA,UADA,IAEA,CAAC,qCAAe,QAAQ,SAAR,EAAf,EAAoC,QAApC,EAA8C,UAA9C,CAAD,EAA4D;AAC9D,gBAAQ,WAAR,CAAoB,wBAClB,8BAA8B,QAA9B,EAAwC,UAAxC,EAAoD,QAApD,CADkB,EAElB,CAAE,IAAF,CAFkB,CAApB,EAD8D;OAFhE;KAjBG;GAAP,CADuE;CAAlE;;AA8BP,SAAS,eAAT,CAAyB,OAAzB,EAAkC,IAAlC,EAAwC;AACtC,MAAM,OAAO,QAAQ,WAAR,CAAoB,IAApB,CAAP,CADgC;AAEtC,SAAO,QAAQ,8BAAY,QAAQ,SAAR,EAAZ,EAAiC,KAAK,aAAL,CAAzC,CAF+B;CAAxC","file":"validation/rules/PossibleFragmentSpreads.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { ValidationContext } from '../index';\nimport { GraphQLError } from '../../error';\nimport { doTypesOverlap } from '../../utilities/typeComparators';\nimport { typeFromAST } from '../../utilities/typeFromAST';\nimport type { GraphQLType } from '../../type/definition';\n\n\nexport function typeIncompatibleSpreadMessage(\n  fragName: string,\n  parentType: GraphQLType,\n  fragType: GraphQLType\n): string {\n  return `Fragment \"${fragName}\" cannot be spread here as objects of ` +\n    `type \"${parentType}\" can never be of type \"${fragType}\".`;\n}\n\nexport function typeIncompatibleAnonSpreadMessage(\n  parentType: GraphQLType,\n  fragType: GraphQLType\n): string {\n  return 'Fragment cannot be spread here as objects of ' +\n    `type \"${parentType}\" can never be of type \"${fragType}\".`;\n}\n\n/**\n * Possible fragment spread\n *\n * A fragment spread is only valid if the type condition could ever possibly\n * be true: if there is a non-empty intersection of the possible parent types,\n * and possible types which pass the type condition.\n */\nexport function PossibleFragmentSpreads(context: ValidationContext): any {\n  return {\n    InlineFragment(node) {\n      const fragType = context.getType();\n      const parentType = context.getParentType();\n      if (fragType &&\n          parentType &&\n          !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(\n          typeIncompatibleAnonSpreadMessage(parentType, fragType),\n          [ node ]\n        ));\n      }\n    },\n    FragmentSpread(node) {\n      const fragName = node.name.value;\n      const fragType = getFragmentType(context, fragName);\n      const parentType = context.getParentType();\n      if (fragType &&\n          parentType &&\n          !doTypesOverlap(context.getSchema(), fragType, parentType)) {\n        context.reportError(new GraphQLError(\n          typeIncompatibleSpreadMessage(fragName, parentType, fragType),\n          [ node ]\n        ));\n      }\n    }\n  };\n}\n\nfunction getFragmentType(context, name) {\n  const frag = context.getFragment(name);\n  return frag && typeFromAST(context.getSchema(), frag.typeCondition);\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}