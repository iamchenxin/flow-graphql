{"version":3,"sources":["execution/execute.js"],"names":[],"mappings":"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","file":"execution/execute.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport { forEach, isCollection } from 'iterall';\n\nimport { GraphQLError, locatedError } from '../error';\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport isNullish from '../jsutils/isNullish';\nimport { typeFromAST } from '../utilities/typeFromAST';\nimport { Kind } from '../language';\nimport { getVariableValues, getArgumentValues } from './values';\nimport {\n  GraphQLScalarType,\n  GraphQLObjectType,\n  GraphQLEnumType,\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  isAbstractType\n} from '../type/definition';\nimport type {\n  GraphQLType,\n  GraphQLLeafType,\n  GraphQLAbstractType,\n  GraphQLFieldDefinition,\n  GraphQLFieldResolveFn,\n  GraphQLResolveInfo,\n} from '../type/definition';\nimport { GraphQLSchema } from '../type/schema';\nimport {\n  SchemaMetaFieldDef,\n  TypeMetaFieldDef,\n  TypeNameMetaFieldDef\n} from '../type/introspection';\nimport {\n  GraphQLIncludeDirective,\n  GraphQLSkipDirective\n} from '../type/directives';\nimport type {\n  Directive,\n  Document,\n  OperationDefinition,\n  SelectionSet,\n  Field,\n  InlineFragment,\n  FragmentDefinition\n} from '../language/ast';\n\n\n/**\n * Terminology\n *\n * \"Definitions\" are the generic name for top-level statements in the document.\n * Examples of this include:\n * 1) Operations (such as a query)\n * 2) Fragments\n *\n * \"Operations\" are a generic name for requests in the document.\n * Examples of this include:\n * 1) query,\n * 2) mutation\n *\n * \"Selections\" are the definitions that can appear legally and at\n * single level of the query. These include:\n * 1) field references e.g \"a\"\n * 2) fragment \"spreads\" e.g. \"...c\"\n * 3) inline fragment \"spreads\" e.g. \"...on Type { a }\"\n */\n\n/**\n * Data that must be available at all points during query execution.\n *\n * Namely, schema of the type system that is currently executing,\n * and the fragments defined in the query document\n */\ntype ExecutionContext = {\n  schema: GraphQLSchema;\n  fragments: {[key: string]: FragmentDefinition};\n  rootValue: mixed;\n  contextValue: mixed;\n  operation: OperationDefinition;\n  variableValues: {[key: string]: mixed};\n  errors: Array<GraphQLError>;\n}\n\n/**\n * The result of execution. `data` is the result of executing the\n * query, `errors` is null if no errors occurred, and is a\n * non-empty array if an error occurred.\n */\ntype ExecutionResult = {\n  data: ?Object;\n  errors?: Array<GraphQLError>;\n}\n\n/**\n * Implements the \"Evaluating requests\" section of the GraphQL specification.\n *\n * Returns a Promise that will eventually be resolved and never rejected.\n *\n * If the arguments to this function do not result in a legal execution context,\n * a GraphQLError will be thrown immediately explaining the invalid input.\n */\nexport function execute(\n  schema: GraphQLSchema,\n  documentAST: Document,\n  rootValue?: mixed,\n  contextValue?: mixed,\n  variableValues?: ?{[key: string]: mixed},\n  operationName?: ?string\n): Promise<ExecutionResult> {\n  invariant(schema, 'Must provide schema');\n  invariant(\n    schema instanceof GraphQLSchema,\n    'Schema must be an instance of GraphQLSchema. Also ensure that there are ' +\n    'not multiple versions of GraphQL installed in your node_modules directory.'\n  );\n\n  // If a valid context cannot be created due to incorrect arguments,\n  // this will throw an error.\n  const context = buildExecutionContext(\n    schema,\n    documentAST,\n    rootValue,\n    contextValue,\n    variableValues,\n    operationName\n  );\n\n  // Return a Promise that will eventually resolve to the data described by\n  // The \"Response\" section of the GraphQL specification.\n  //\n  // If errors are encountered while executing a GraphQL field, only that\n  // field and its descendants will be omitted, and sibling fields will still\n  // be executed. An execution which encounters errors will still result in a\n  // resolved Promise.\n  return new Promise(resolve => {\n    resolve(executeOperation(context, context.operation, rootValue));\n  }).catch(error => {\n    // Errors from sub-fields of a NonNull type may propagate to the top level,\n    // at which point we still log the error and null the parent field, which\n    // in this case is the entire response.\n    context.errors.push(error);\n    return null;\n  }).then(data => {\n    if (!context.errors.length) {\n      return { data };\n    }\n    return { data, errors: context.errors };\n  });\n}\n\n/**\n * Constructs a ExecutionContext object from the arguments passed to\n * execute, which we will pass throughout the other execution methods.\n *\n * Throws a GraphQLError if a valid execution context cannot be created.\n */\nfunction buildExecutionContext(\n  schema: GraphQLSchema,\n  documentAST: Document,\n  rootValue: mixed,\n  contextValue: mixed,\n  rawVariableValues: ?{[key: string]: mixed},\n  operationName: ?string\n): ExecutionContext {\n  const errors: Array<GraphQLError> = [];\n  let operation: ?OperationDefinition;\n  const fragments: {[name: string]: FragmentDefinition} = Object.create(null);\n  documentAST.definitions.forEach(definition => {\n    switch (definition.kind) {\n      case Kind.OPERATION_DEFINITION:\n        if (!operationName && operation) {\n          throw new GraphQLError(\n            'Must provide operation name if query contains multiple operations.'\n          );\n        }\n        if (!operationName ||\n            definition.name && definition.name.value === operationName) {\n          operation = definition;\n        }\n        break;\n      case Kind.FRAGMENT_DEFINITION:\n        fragments[definition.name.value] = definition;\n        break;\n      default: throw new GraphQLError(\n        `GraphQL cannot execute a request containing a ${definition.kind}.`,\n        [ definition ]\n      );\n    }\n  });\n  if (!operation) {\n    if (operationName) {\n      throw new GraphQLError(`Unknown operation named \"${operationName}\".`);\n    } else {\n      throw new GraphQLError('Must provide an operation.');\n    }\n  }\n  const variableValues = getVariableValues(\n    schema,\n    operation.variableDefinitions || [],\n    rawVariableValues || {}\n  );\n\n  return {\n    schema,\n    fragments,\n    rootValue,\n    contextValue,\n    operation,\n    variableValues,\n    errors\n  };\n}\n\n/**\n * Implements the \"Evaluating operations\" section of the spec.\n */\nfunction executeOperation(\n  exeContext: ExecutionContext,\n  operation: OperationDefinition,\n  rootValue: mixed\n): Object {\n  const type = getOperationRootType(exeContext.schema, operation);\n  const fields = collectFields(\n    exeContext,\n    type,\n    operation.selectionSet,\n    Object.create(null),\n    Object.create(null)\n  );\n\n  const path = [];\n\n  if (operation.operation === 'mutation') {\n    return executeFieldsSerially(exeContext, type, rootValue, path, fields);\n  }\n  return executeFields(exeContext, type, rootValue, path, fields);\n}\n\n/**\n * Extracts the root type of the operation from the schema.\n */\nfunction getOperationRootType(\n  schema: GraphQLSchema,\n  operation: OperationDefinition\n): GraphQLObjectType {\n  switch (operation.operation) {\n    case 'query':\n      return schema.getQueryType();\n    case 'mutation':\n      const mutationType = schema.getMutationType();\n      if (!mutationType) {\n        throw new GraphQLError(\n          'Schema is not configured for mutations',\n          [ operation ]\n        );\n      }\n      return mutationType;\n    case 'subscription':\n      const subscriptionType = schema.getSubscriptionType();\n      if (!subscriptionType) {\n        throw new GraphQLError(\n          'Schema is not configured for subscriptions',\n          [ operation ]\n        );\n      }\n      return subscriptionType;\n    default:\n      throw new GraphQLError(\n        'Can only execute queries, mutations and subscriptions',\n        [ operation ]\n      );\n  }\n}\n\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"write\" mode.\n */\nfunction executeFieldsSerially(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: mixed,\n  path: Array<string | number>,\n  fields: {[key: string]: Array<Field>}\n): Promise<Object> {\n  return Object.keys(fields).reduce(\n    (prevPromise, responseName) => prevPromise.then(results => {\n      const fieldASTs = fields[responseName];\n      const fieldPath = path.concat([ responseName ]);\n      const result = resolveField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldASTs,\n        fieldPath\n      );\n      if (result === undefined) {\n        return results;\n      }\n      if (isThenable(result)) {\n        return ((result: any): Promise<*>).then(resolvedResult => {\n          results[responseName] = resolvedResult;\n          return results;\n        });\n      }\n      results[responseName] = result;\n      return results;\n    }),\n    Promise.resolve({})\n  );\n}\n\n/**\n * Implements the \"Evaluating selection sets\" section of the spec\n * for \"read\" mode.\n */\nfunction executeFields(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  sourceValue: mixed,\n  path: Array<string | number>,\n  fields: {[key: string]: Array<Field>}\n): Object {\n  let containsPromise = false;\n\n  const finalResults = Object.keys(fields).reduce(\n    (results, responseName) => {\n      const fieldASTs = fields[responseName];\n      const fieldPath = path.concat([ responseName ]);\n      const result = resolveField(\n        exeContext,\n        parentType,\n        sourceValue,\n        fieldASTs,\n        fieldPath\n      );\n      if (result === undefined) {\n        return results;\n      }\n      results[responseName] = result;\n      if (isThenable(result)) {\n        containsPromise = true;\n      }\n      return results;\n    },\n    Object.create(null)\n  );\n\n  // If there are no promises, we can just return the object\n  if (!containsPromise) {\n    return finalResults;\n  }\n\n  // Otherwise, results is a map from field name to the result\n  // of resolving that field, which is possibly a promise. Return\n  // a promise that will return this same map, but with any\n  // promises replaced with the values they resolved to.\n  return promiseForObject(finalResults);\n}\n\n/**\n * Given a selectionSet, adds all of the fields in that selection to\n * the passed in map of fields, and returns it at the end.\n *\n * CollectFields requires the \"runtime type\" of an object. For a field which\n * returns and Interface or Union type, the \"runtime type\" will be the actual\n * Object type returned by that field.\n */\nfunction collectFields(\n  exeContext: ExecutionContext,\n  runtimeType: GraphQLObjectType,\n  selectionSet: SelectionSet,\n  fields: {[key: string]: Array<Field>},\n  visitedFragmentNames: {[key: string]: boolean}\n): {[key: string]: Array<Field>} {\n  for (let i = 0; i < selectionSet.selections.length; i++) {\n    const selection = selectionSet.selections[i];\n    switch (selection.kind) {\n      case Kind.FIELD:\n        if (!shouldIncludeNode(exeContext, selection.directives)) {\n          continue;\n        }\n        const name = getFieldEntryKey(selection);\n        if (!fields[name]) {\n          fields[name] = [];\n        }\n        fields[name].push(selection);\n        break;\n      case Kind.INLINE_FRAGMENT:\n        if (!shouldIncludeNode(exeContext, selection.directives) ||\n            !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n          continue;\n        }\n        collectFields(\n          exeContext,\n          runtimeType,\n          selection.selectionSet,\n          fields,\n          visitedFragmentNames\n        );\n        break;\n      case Kind.FRAGMENT_SPREAD:\n        const fragName = selection.name.value;\n        if (visitedFragmentNames[fragName] ||\n            !shouldIncludeNode(exeContext, selection.directives)) {\n          continue;\n        }\n        visitedFragmentNames[fragName] = true;\n        const fragment = exeContext.fragments[fragName];\n        if (!fragment ||\n            !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n          continue;\n        }\n        collectFields(\n          exeContext,\n          runtimeType,\n          fragment.selectionSet,\n          fields,\n          visitedFragmentNames\n        );\n        break;\n    }\n  }\n  return fields;\n}\n\n/**\n * Determines if a field should be included based on the @include and @skip\n * directives, where @skip has higher precidence than @include.\n */\nfunction shouldIncludeNode(\n  exeContext: ExecutionContext,\n  directives: ?Array<Directive>\n): boolean {\n  const skipAST = directives && find(\n    directives,\n    directive => directive.name.value === GraphQLSkipDirective.name\n  );\n  if (skipAST) {\n    const { if: skipIf } = getArgumentValues(\n      GraphQLSkipDirective.args,\n      skipAST.arguments,\n      exeContext.variableValues\n    );\n    if (skipIf === true) {\n      return false;\n    }\n  }\n\n  const includeAST = directives && find(\n    directives,\n    directive => directive.name.value === GraphQLIncludeDirective.name\n  );\n  if (includeAST) {\n    const { if: includeIf } = getArgumentValues(\n      GraphQLIncludeDirective.args,\n      includeAST.arguments,\n      exeContext.variableValues\n    );\n    if (includeIf === false) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines if a fragment is applicable to the given type.\n */\nfunction doesFragmentConditionMatch(\n  exeContext: ExecutionContext,\n  fragment: FragmentDefinition | InlineFragment,\n  type: GraphQLObjectType\n): boolean {\n  const typeConditionAST = fragment.typeCondition;\n  if (!typeConditionAST) {\n    return true;\n  }\n  const conditionalType = typeFromAST(exeContext.schema, typeConditionAST);\n  if (conditionalType === type) {\n    return true;\n  }\n  if (isAbstractType(conditionalType)) {\n    const abstractType = ((conditionalType: any): GraphQLAbstractType);\n    return exeContext.schema.isPossibleType(abstractType, type);\n  }\n  return false;\n}\n\n/**\n * This function transforms a JS object `{[key: string]: Promise<T>}` into\n * a `Promise<{[key: string]: T}>`\n *\n * This is akin to bluebird's `Promise.props`, but implemented only using\n * `Promise.all` so it will work with any implementation of ES6 promises.\n */\nfunction promiseForObject<T>(\n  object: {[key: string]: Promise<T>}\n): Promise<{[key: string]: T}> {\n  const keys = Object.keys(object);\n  const valuesAndPromises = keys.map(name => object[name]);\n  return Promise.all(valuesAndPromises).then(\n    values => values.reduce((resolvedObject, value, i) => {\n      resolvedObject[keys[i]] = value;\n      return resolvedObject;\n    }, Object.create(null))\n  );\n}\n\n/**\n * Implements the logic to compute the key of a given field's entry\n */\nfunction getFieldEntryKey(node: Field): string {\n  return node.alias ? node.alias.value : node.name.value;\n}\n\n/**\n * Resolves the field on the given source object. In particular, this\n * figures out the value that the field returns by calling its resolve function,\n * then calls completeValue to complete promises, serialize scalars, or execute\n * the sub-selection-set for objects.\n */\nfunction resolveField(\n  exeContext: ExecutionContext,\n  parentType: GraphQLObjectType,\n  source: mixed,\n  fieldASTs: Array<Field>,\n  path: Array<string | number>\n): mixed {\n  const fieldAST = fieldASTs[0];\n  const fieldName = fieldAST.name.value;\n\n  const fieldDef = getFieldDef(exeContext.schema, parentType, fieldName);\n  if (!fieldDef) {\n    return;\n  }\n\n  const returnType = fieldDef.type;\n  const resolveFn = fieldDef.resolve || defaultResolveFn;\n\n  // Build a JS object of arguments from the field.arguments AST, using the\n  // variables scope to fulfill any variable references.\n  // TODO: find a way to memoize, in case this field is within a List type.\n  const args = getArgumentValues(\n    fieldDef.args,\n    fieldAST.arguments,\n    exeContext.variableValues\n  );\n\n  // The resolve function's optional third argument is a context value that\n  // is provided to every resolve function within an execution. It is commonly\n  // used to represent an authenticated user, or request-specific caches.\n  const context = exeContext.contextValue;\n\n  // The resolve function's optional fourth argument is a collection of\n  // information about the current execution state.\n  const info: GraphQLResolveInfo = {\n    fieldName,\n    fieldASTs,\n    returnType,\n    parentType,\n    path,\n    schema: exeContext.schema,\n    fragments: exeContext.fragments,\n    rootValue: exeContext.rootValue,\n    operation: exeContext.operation,\n    variableValues: exeContext.variableValues,\n  };\n\n  // Get the resolve function, regardless of if its result is normal\n  // or abrupt (error).\n  const result = resolveOrError(resolveFn, source, args, context, info);\n\n  return completeValueCatchingError(\n    exeContext,\n    returnType,\n    fieldASTs,\n    info,\n    path,\n    result\n  );\n}\n\n// Isolates the \"ReturnOrAbrupt\" behavior to not de-opt the `resolveField`\n// function. Returns the result of resolveFn or the abrupt-return Error object.\nfunction resolveOrError(\n  resolveFn: GraphQLFieldResolveFn<*, *>,\n  source: mixed,\n  args: { [key: string]: mixed },\n  context: mixed,\n  info: GraphQLResolveInfo\n): Error | mixed {\n  try {\n    return resolveFn(source, args, context, info);\n  } catch (error) {\n    // Sometimes a non-error is thrown, wrap it as an Error for a\n    // consistent interface.\n    return error instanceof Error ? error : new Error(error);\n  }\n}\n\n// This is a small wrapper around completeValue which detects and logs errors\n// in the execution context.\nfunction completeValueCatchingError(\n  exeContext: ExecutionContext,\n  returnType: GraphQLType,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  // If the field type is non-nullable, then it is resolved without any\n  // protection from errors, however it still properly locates the error.\n  if (returnType instanceof GraphQLNonNull) {\n    return completeValueWithLocatedError(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n  }\n\n  // Otherwise, error protection is applied, logging the error and resolving\n  // a null value for this field if one is encountered.\n  try {\n    const completed = completeValueWithLocatedError(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n    if (isThenable(completed)) {\n      // If `completeValueWithLocatedError` returned a rejected promise, log\n      // the rejection error and resolve to null.\n      // Note: we don't rely on a `catch` method, but we do expect \"thenable\"\n      // to take a second callback for the error case.\n      return ((completed: any): Promise<*>).then(undefined, error => {\n        exeContext.errors.push(error);\n        return Promise.resolve(null);\n      });\n    }\n    return completed;\n  } catch (error) {\n    // If `completeValueWithLocatedError` returned abruptly (threw an error),\n    // log the error and return null.\n    exeContext.errors.push(error);\n    return null;\n  }\n}\n\n// This is a small wrapper around completeValue which annotates errors with\n// location information.\nfunction completeValueWithLocatedError(\n  exeContext: ExecutionContext,\n  returnType: GraphQLType,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  try {\n    const completed = completeValue(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n    if (isThenable(completed)) {\n      return ((completed: any): Promise<*>).catch(\n        error => Promise.reject(locatedError(error, fieldASTs, path))\n      );\n    }\n    return completed;\n  } catch (error) {\n    throw locatedError(error, fieldASTs, path);\n  }\n}\n\n/**\n * Implements the instructions for completeValue as defined in the\n * \"Field entries\" section of the spec.\n *\n * If the field type is Non-Null, then this recursively completes the value\n * for the inner type. It throws a field error if that completion returns null,\n * as per the \"Nullability\" section of the spec.\n *\n * If the field type is a List, then this recursively completes the value\n * for the inner type on each item in the list.\n *\n * If the field type is a Scalar or Enum, ensures the completed value is a legal\n * value of the type by calling the `serialize` method of GraphQL type\n * definition.\n *\n * If the field is an abstract type, determine the runtime type of the value\n * and then complete based on that type\n *\n * Otherwise, the field type expects a sub-selection set, and will complete the\n * value by evaluating all sub-selections.\n */\nfunction completeValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLType,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  // If result is a Promise, apply-lift over completeValue.\n  if (isThenable(result)) {\n    return ((result: any): Promise<*>).then(\n      resolved => completeValue(\n        exeContext,\n        returnType,\n        fieldASTs,\n        info,\n        path,\n        resolved\n      )\n    );\n  }\n\n  // If result is an Error, throw a located error.\n  if (result instanceof Error) {\n    throw result;\n  }\n\n  // If field type is NonNull, complete for inner type, and throw field error\n  // if result is null.\n  if (returnType instanceof GraphQLNonNull) {\n    const completed = completeValue(\n      exeContext,\n      returnType.ofType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n    if (completed === null) {\n      throw new Error(\n        `Cannot return null for non-nullable field ${\n          info.parentType.name}.${info.fieldName}.`\n      );\n    }\n    return completed;\n  }\n\n  // If result value is null-ish (null, undefined, or NaN) then return null.\n  if (isNullish(result)) {\n    return null;\n  }\n\n  // If field type is List, complete each item in the list with the inner type\n  if (returnType instanceof GraphQLList) {\n    return completeListValue(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n  }\n\n  // If field type is a leaf type, Scalar or Enum, serialize to a valid value,\n  // returning null if serialization is not possible.\n  if (returnType instanceof GraphQLScalarType ||\n      returnType instanceof GraphQLEnumType) {\n    return completeLeafValue(returnType, result);\n  }\n\n  // If field type is an abstract type, Interface or Union, determine the\n  // runtime Object type and complete for that type.\n  if (returnType instanceof GraphQLInterfaceType ||\n      returnType instanceof GraphQLUnionType) {\n    return completeAbstractValue(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n  }\n\n  // If field type is Object, execute and complete all sub-selections.\n  if (returnType instanceof GraphQLObjectType) {\n    return completeObjectValue(\n      exeContext,\n      returnType,\n      fieldASTs,\n      info,\n      path,\n      result\n    );\n  }\n\n  // Not reachable. All possible output types have been considered.\n  throw new Error(\n    `Cannot complete value of unexpected type \"${String(returnType)}\".`\n  );\n}\n\n/**\n * Complete a list value by completing each item in the list with the\n * inner type\n */\nfunction completeListValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLList<*>,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  invariant(\n    isCollection(result),\n    `Expected Iterable, but did not find one for field ${\n      info.parentType.name}.${info.fieldName}.`\n  );\n\n  // This is specified as a simple map, however we're optimizing the path\n  // where the list contains no Promises by avoiding creating another Promise.\n  const itemType = returnType.ofType;\n  let containsPromise = false;\n  const completedResults = [];\n  forEach((result: any), (item, index) => {\n    // No need to modify the info object containing the path,\n    // since from here on it is not ever accessed by resolver functions.\n    const fieldPath = path.concat([ index ]);\n    const completedItem = completeValueCatchingError(\n      exeContext,\n      itemType,\n      fieldASTs,\n      info,\n      fieldPath,\n      item\n    );\n\n    if (!containsPromise && isThenable(completedItem)) {\n      containsPromise = true;\n    }\n    completedResults.push(completedItem);\n  });\n\n  return containsPromise ? Promise.all(completedResults) : completedResults;\n}\n\n/**\n * Complete a Scalar or Enum by serializing to a valid value, returning\n * null if serialization is not possible.\n */\nfunction completeLeafValue(\n  returnType: GraphQLLeafType,\n  result: mixed\n): mixed {\n  invariant(returnType.serialize, 'Missing serialize method on type');\n  const serializedResult = returnType.serialize(result);\n  if (isNullish(serializedResult)) {\n    throw new Error(\n      `Expected a value of type \"${String(returnType)}\" but ` +\n      `received: ${String(result)}`\n    );\n  }\n  return serializedResult;\n}\n\n/**\n * Complete a value of an abstract type by determining the runtime object type\n * of that value, then complete the value for that type.\n */\nfunction completeAbstractValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLAbstractType,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  const runtimeType = returnType.resolveType ?\n    returnType.resolveType(result, exeContext.contextValue, info) :\n    defaultResolveTypeFn(result, exeContext.contextValue, info, returnType);\n\n  if (!(runtimeType instanceof GraphQLObjectType)) {\n    throw new GraphQLError(\n      `Abstract type ${returnType.name} must resolve to an Object type at ` +\n      `runtime for field ${info.parentType.name}.${info.fieldName} with ` +\n      `value \"${String(result)}\", received \"${String(runtimeType)}\".`,\n      fieldASTs\n    );\n  }\n\n  if (!exeContext.schema.isPossibleType(returnType, runtimeType)) {\n    throw new GraphQLError(\n      `Runtime Object type \"${runtimeType.name}\" is not a possible type ` +\n      `for \"${returnType.name}\".`,\n      fieldASTs\n    );\n  }\n\n  return completeObjectValue(\n    exeContext,\n    runtimeType,\n    fieldASTs,\n    info,\n    path,\n    result\n  );\n}\n\n/**\n * Complete an Object value by executing all sub-selections.\n */\nfunction completeObjectValue(\n  exeContext: ExecutionContext,\n  returnType: GraphQLObjectType,\n  fieldASTs: Array<Field>,\n  info: GraphQLResolveInfo,\n  path: Array<string | number>,\n  result: mixed\n): mixed {\n  // If there is an isTypeOf predicate function, call it with the\n  // current result. If isTypeOf returns false, then raise an error rather\n  // than continuing execution.\n  if (returnType.isTypeOf &&\n      !returnType.isTypeOf(result, exeContext.contextValue, info)) {\n    throw new GraphQLError(\n      `Expected value of type \"${returnType.name}\" but got: ${String(result)}.`,\n      fieldASTs\n    );\n  }\n\n  // Collect sub-fields to execute to complete this value.\n  let subFieldASTs = Object.create(null);\n  const visitedFragmentNames = Object.create(null);\n  for (let i = 0; i < fieldASTs.length; i++) {\n    const selectionSet = fieldASTs[i].selectionSet;\n    if (selectionSet) {\n      subFieldASTs = collectFields(\n        exeContext,\n        returnType,\n        selectionSet,\n        subFieldASTs,\n        visitedFragmentNames\n      );\n    }\n  }\n\n  return executeFields(exeContext, returnType, result, path, subFieldASTs);\n}\n\n/**\n * If a resolveType function is not given, then a default resolve behavior is\n * used which tests each possible type for the abstract type by calling\n * isTypeOf for the object being coerced, returning the first type that matches.\n */\nfunction defaultResolveTypeFn(\n  value: mixed,\n  context: mixed,\n  info: GraphQLResolveInfo,\n  abstractType: GraphQLAbstractType\n): ?GraphQLObjectType {\n  const possibleTypes = info.schema.getPossibleTypes(abstractType);\n  for (let i = 0; i < possibleTypes.length; i++) {\n    const type = possibleTypes[i];\n    if (type.isTypeOf && type.isTypeOf(value, context, info)) {\n      return type;\n    }\n  }\n}\n\n/**\n * If a resolve function is not given, then a default resolve behavior is used\n * which takes the property of the source object of the same name as the field\n * and returns it as the result, or if it's a function, returns the result\n * of calling that function.\n */\nfunction defaultResolveFn(source: any, args, context, { fieldName }) {\n  // ensure source is a value for which property access is acceptable.\n  if (typeof source === 'object' || typeof source === 'function') {\n    const property = source[fieldName];\n    return typeof property === 'function' ? source[fieldName]() : property;\n  }\n}\n\n/**\n * Checks to see if this object acts like a Promise, i.e. has a \"then\"\n * function.\n */\nfunction isThenable(value: mixed): boolean {\n  return typeof value === 'object' &&\n    value !== null &&\n    typeof value.then === 'function';\n}\n\n/**\n * This method looks up the field on the given type defintion.\n * It has special casing for the two introspection fields, __schema\n * and __typename. __typename is special because it can always be\n * queried as a field, even in situations where no other fields\n * are allowed, like on a Union. __schema could get automatically\n * added to the query type, but that would require mutating type\n * definitions, which would cause issues.\n */\nfunction getFieldDef(\n  schema: GraphQLSchema,\n  parentType: GraphQLObjectType,\n  fieldName: string\n): ?GraphQLFieldDefinition {\n  if (fieldName === SchemaMetaFieldDef.name &&\n      schema.getQueryType() === parentType) {\n    return SchemaMetaFieldDef;\n  } else if (fieldName === TypeMetaFieldDef.name &&\n             schema.getQueryType() === parentType) {\n    return TypeMetaFieldDef;\n  } else if (fieldName === TypeNameMetaFieldDef.name) {\n    return TypeNameMetaFieldDef;\n  }\n  return parentType.getFields()[fieldName];\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}