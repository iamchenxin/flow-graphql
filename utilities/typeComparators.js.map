{"version":3,"sources":["utilities/typeComparators.js"],"names":[],"mappings":";;;;;QA+BgB;QAwBA;QAwDA;;AArGhB;;;;;AAqBO,SAAS,WAAT,CAAqB,KAArB,EAAyC,KAAzC,EAAsE;;AAE3E,MAAI,UAAU,KAAV,EAAiB;AACnB,WAAO,IAAP,CADmB;GAArB;;;AAF2E,MAOvE,+CAAmC,2CAAnC,EAAoE;AACtE,WAAO,YAAY,MAAM,MAAN,EAAc,MAAM,MAAN,CAAjC,CADsE;GAAxE;;;AAP2E,MAYvE,4CAAgC,wCAAhC,EAA8D;AAChE,WAAO,YAAY,MAAM,MAAN,EAAc,MAAM,MAAN,CAAjC,CADgE;GAAlE;;;AAZ2E,SAiBpE,KAAP,CAjB2E;CAAtE;;;;;;;;;;;;;;;;AAwBA,SAAS,eAAT,CACL,MADK,EAEL,YAFK,EAGL,SAHK,EAII;;AAET,MAAI,iBAAiB,SAAjB,EAA4B;AAC9B,WAAO,IAAP,CAD8B;GAAhC;;;AAFS,MAOL,+CAAJ,EAAyC;AACvC,QAAI,kDAAJ,EAA4C;AAC1C,aAAO,gBAAgB,MAAhB,EAAwB,aAAa,MAAb,EAAqB,UAAU,MAAV,CAApD,CAD0C;KAA5C;AAGA,WAAO,KAAP,CAJuC;GAAzC,MAKO,IAAI,kDAAJ,EAA4C;;AAEjD,WAAO,gBAAgB,MAAhB,EAAwB,aAAa,MAAb,EAAqB,SAA7C,CAAP,CAFiD;GAA5C;;;AAZE,MAkBL,4CAAJ,EAAsC;AACpC,QAAI,+CAAJ,EAAyC;AACvC,aAAO,gBAAgB,MAAhB,EAAwB,aAAa,MAAb,EAAqB,UAAU,MAAV,CAApD,CADuC;KAAzC;AAGA,WAAO,KAAP,CAJoC;GAAtC,MAKO,IAAI,+CAAJ,EAAyC;;AAE9C,WAAO,KAAP,CAF8C;GAAzC;;;;AAvBE,MA8BL,gCAAe,SAAf,KACA,qDADA,IAEA,OAAO,cAAP,CACI,SADJ,EAEE,YAFF,CAFA,EAKG;AACL,WAAO,IAAP,CADK;GALP;;;AA9BS,SAwCF,KAAP,CAxCS;CAJJ;;;;;;;;;;;AAwDA,SAAS,cAAT,CACL,MADK,EAEL,KAFK,EAGL,KAHK,EAII;;AAET,MAAM,SAAS,KAAT;;;AAFG,MAKL,UAAU,MAAV,EAAkB;AACpB,WAAO,IAAP,CADoB;GAAtB;;AAIA,MAAI,qDACA,6CADA,EACmC;AACrC,QAAI,sDACA,8CADA,EACoC;;;AAGtC,aAAO,OAAO,gBAAP,CAAwB,KAAxB,EAA+B,IAA/B,CACL;eAAQ,OAAO,cAAP,CAAsB,MAAtB,EAA8B,IAA9B;OAAR,CADF,CAHsC;KADxC;;AADqC,WAU9B,OAAO,cAAP,CAAsB,KAAtB,EAA6B,MAA7B,CAAP,CAVqC;GADvC;;AAcA,MAAI,sDACA,8CADA,EACoC;;AAEtC,WAAO,OAAO,cAAP,CAAsB,MAAtB,EAA8B,KAA9B,CAAP,CAFsC;GADxC;;;AAvBS,SA8BF,KAAP,CA9BS;CAJJ","file":"utilities/typeComparators.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport {\n  isAbstractType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLList,\n  GraphQLNonNull,\n} from '../type/definition';\nimport type {\n  GraphQLType,\n  GraphQLCompositeType,\n  GraphQLAbstractType\n} from '../type/definition';\nimport type {\n  GraphQLSchema\n} from '../type/schema';\n\n\n/**\n * Provided two types, return true if the types are equal (invariant).\n */\nexport function isEqualType(typeA: GraphQLType, typeB: GraphQLType): boolean {\n  // Equivalent types are equal.\n  if (typeA === typeB) {\n    return true;\n  }\n\n  // If either type is non-null, the other must also be non-null.\n  if (typeA instanceof GraphQLNonNull && typeB instanceof GraphQLNonNull) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // If either type is a list, the other must also be a list.\n  if (typeA instanceof GraphQLList && typeB instanceof GraphQLList) {\n    return isEqualType(typeA.ofType, typeB.ofType);\n  }\n\n  // Otherwise the types are not equal.\n  return false;\n}\n\n/**\n * Provided a type and a super type, return true if the first type is either\n * equal or a subset of the second super type (covariant).\n */\nexport function isTypeSubTypeOf(\n  schema: GraphQLSchema,\n  maybeSubType: GraphQLType,\n  superType: GraphQLType\n): boolean {\n  // Equivalent type is a valid subtype\n  if (maybeSubType === superType) {\n    return true;\n  }\n\n  // If superType is non-null, maybeSubType must also be nullable.\n  if (superType instanceof GraphQLNonNull) {\n    if (maybeSubType instanceof GraphQLNonNull) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof GraphQLNonNull) {\n    // If superType is nullable, maybeSubType may be non-null.\n    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);\n  }\n\n  // If superType type is a list, maybeSubType type must also be a list.\n  if (superType instanceof GraphQLList) {\n    if (maybeSubType instanceof GraphQLList) {\n      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);\n    }\n    return false;\n  } else if (maybeSubType instanceof GraphQLList) {\n    // If superType is not a list, maybeSubType must also be not a list.\n    return false;\n  }\n\n  // If superType type is an abstract type, maybeSubType type may be a currently\n  // possible object type.\n  if (isAbstractType(superType) &&\n      maybeSubType instanceof GraphQLObjectType &&\n      schema.isPossibleType(\n        ((superType: any): GraphQLAbstractType),\n        maybeSubType\n      )) {\n    return true;\n  }\n\n  // Otherwise, the child type is not a valid subtype of the parent type.\n  return false;\n}\n\n/**\n * Provided two composite types, determine if they \"overlap\". Two composite\n * types overlap when the Sets of possible concrete types for each intersect.\n *\n * This is often used to determine if a fragment of a given type could possibly\n * be visited in a context of another type.\n *\n * This function is commutative.\n */\nexport function doTypesOverlap(\n  schema: GraphQLSchema,\n  typeA: GraphQLCompositeType,\n  typeB: GraphQLCompositeType\n): boolean {\n  // So flow is aware this is constant\n  const _typeB = typeB;\n\n  // Equivalent types overlap\n  if (typeA === _typeB) {\n    return true;\n  }\n\n  if (typeA instanceof GraphQLInterfaceType ||\n      typeA instanceof GraphQLUnionType) {\n    if (_typeB instanceof GraphQLInterfaceType ||\n        _typeB instanceof GraphQLUnionType) {\n      // If both types are abstract, then determine if there is any intersection\n      // between possible concrete types of each.\n      return schema.getPossibleTypes(typeA).some(\n        type => schema.isPossibleType(_typeB, type)\n      );\n    }\n    // Determine if the latter type is a possible concrete type of the former.\n    return schema.isPossibleType(typeA, _typeB);\n  }\n\n  if (_typeB instanceof GraphQLInterfaceType ||\n      _typeB instanceof GraphQLUnionType) {\n    // Determine if the former type is a possible concrete type of the latter.\n    return schema.isPossibleType(_typeB, typeA);\n  }\n\n  // Otherwise the types do not overlap.\n  return false;\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}