{"version":3,"sources":["utilities/buildASTSchema.js"],"names":[],"mappings":"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","file":"utilities/buildASTSchema.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\nimport { TokenKind } from '../language/lexer';\nimport { parse } from '../language/parser';\nimport type { Source } from '../language/source';\nimport { getArgumentValues } from '../execution/values';\n\nimport {\n  LIST_TYPE,\n  NON_NULL_TYPE,\n  DOCUMENT,\n  SCHEMA_DEFINITION,\n  SCALAR_TYPE_DEFINITION,\n  OBJECT_TYPE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n  DIRECTIVE_DEFINITION,\n} from '../language/kinds';\n\nimport type {\n  Location,\n  Document,\n  Directive,\n  Type,\n  NamedType,\n  SchemaDefinition,\n  TypeDefinition,\n  ScalarTypeDefinition,\n  ObjectTypeDefinition,\n  InputValueDefinition,\n  InterfaceTypeDefinition,\n  UnionTypeDefinition,\n  EnumTypeDefinition,\n  InputObjectTypeDefinition,\n  DirectiveDefinition,\n} from '../language/ast';\n\nimport { GraphQLSchema } from '../type/schema';\n\nimport {\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n} from '../type/scalars';\n\nimport {\n  GraphQLScalarType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLList,\n  GraphQLNonNull,\n  isInputType,\n  isOutputType,\n} from '../type/definition';\n\nimport type {\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInputType,\n  GraphQLOutputType,\n} from '../type/definition';\n\nimport {\n  GraphQLDirective,\n  GraphQLSkipDirective,\n  GraphQLIncludeDirective,\n  GraphQLDeprecatedDirective,\n} from '../type/directives';\n\nimport type {\n  DirectiveLocationEnum\n} from '../type/directives';\n\nimport {\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind,\n} from '../type/introspection';\n\n\nfunction buildWrappedType(\n  innerType: GraphQLType,\n  inputTypeAST: Type\n): GraphQLType {\n  if (inputTypeAST.kind === LIST_TYPE) {\n    return new GraphQLList(buildWrappedType(innerType, inputTypeAST.type));\n  }\n  if (inputTypeAST.kind === NON_NULL_TYPE) {\n    const wrappedType = buildWrappedType(innerType, inputTypeAST.type);\n    invariant(!(wrappedType instanceof GraphQLNonNull), 'No nesting nonnull.');\n    return new GraphQLNonNull(wrappedType);\n  }\n  return innerType;\n}\n\nfunction getNamedTypeAST(typeAST: Type): NamedType {\n  let namedType = typeAST;\n  while (namedType.kind === LIST_TYPE || namedType.kind === NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n  return namedType;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * If no schema definition is provided, then it will look for types named Query\n * and Mutation.\n *\n * Given that AST it constructs a GraphQLSchema. The resulting schema\n * has no resolve methods, so execution will use default resolvers.\n */\nexport function buildASTSchema(ast: Document): GraphQLSchema {\n  if (!ast || ast.kind !== DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  let schemaDef: ?SchemaDefinition;\n\n  const typeDefs: Array<TypeDefinition> = [];\n  const astMap: {[name: string]: TypeDefinition} = Object.create(null);\n  const directiveDefs: Array<DirectiveDefinition> = [];\n  for (let i = 0; i < ast.definitions.length; i++) {\n    const d = ast.definitions[i];\n    switch (d.kind) {\n      case SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n        schemaDef = d;\n        break;\n      case SCALAR_TYPE_DEFINITION:\n      case OBJECT_TYPE_DEFINITION:\n      case INTERFACE_TYPE_DEFINITION:\n      case ENUM_TYPE_DEFINITION:\n      case UNION_TYPE_DEFINITION:\n      case INPUT_OBJECT_TYPE_DEFINITION:\n        typeDefs.push(d);\n        astMap[d.name.value] = d;\n        break;\n      case DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  let queryTypeName;\n  let mutationTypeName;\n  let subscriptionTypeName;\n  if (schemaDef) {\n    schemaDef.operationTypes.forEach(operationType => {\n      const typeName = operationType.type.name.value;\n      if (operationType.operation === 'query') {\n        if (queryTypeName) {\n          throw new Error('Must provide only one query type in schema.');\n        }\n        if (!astMap[typeName]) {\n          throw new Error(\n            `Specified query type \"${typeName}\" not found in document.`\n          );\n        }\n        queryTypeName = typeName;\n      } else if (operationType.operation === 'mutation') {\n        if (mutationTypeName) {\n          throw new Error('Must provide only one mutation type in schema.');\n        }\n        if (!astMap[typeName]) {\n          throw new Error(\n            `Specified mutation type \"${typeName}\" not found in document.`\n          );\n        }\n        mutationTypeName = typeName;\n      } else if (operationType.operation === 'subscription') {\n        if (subscriptionTypeName) {\n          throw new Error('Must provide only one subscription type in schema.');\n        }\n        if (!astMap[typeName]) {\n          throw new Error(\n            `Specified subscription type \"${typeName}\" not found in document.`\n          );\n        }\n        subscriptionTypeName = typeName;\n      }\n    });\n  } else {\n    if (astMap.Query) {\n      queryTypeName = 'Query';\n    }\n    if (astMap.Mutation) {\n      mutationTypeName = 'Mutation';\n    }\n    if (astMap.Subscription) {\n      subscriptionTypeName = 'Subscription';\n    }\n  }\n\n  if (!queryTypeName) {\n    throw new Error(\n      'Must provide schema definition with query type or a type named Query.'\n    );\n  }\n\n  const innerTypeMap = {\n    String: GraphQLString,\n    Int: GraphQLInt,\n    Float: GraphQLFloat,\n    Boolean: GraphQLBoolean,\n    ID: GraphQLID,\n    __Schema,\n    __Directive,\n    __DirectiveLocation,\n    __Type,\n    __Field,\n    __InputValue,\n    __EnumValue,\n    __TypeKind,\n  };\n\n  const types = typeDefs.map(def => typeDefNamed(def.name.value));\n\n  const directives = directiveDefs.map(getDirective);\n\n  // If specified directives were not explicitly declared, add them.\n  if (!directives.some(directive => directive.name === 'skip')) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(directive => directive.name === 'include')) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(directive => directive.name === 'deprecated')) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    query: getObjectType(astMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(astMap[mutationTypeName]) : null,\n    subscription:\n      subscriptionTypeName ? getObjectType(astMap[subscriptionTypeName]) : null,\n    types,\n    directives,\n  });\n\n  function getDirective(directiveAST: DirectiveDefinition): GraphQLDirective {\n    return new GraphQLDirective({\n      name: directiveAST.name.value,\n      description: getDescription(directiveAST),\n      locations: directiveAST.locations.map(\n        node => ((node.value: any): DirectiveLocationEnum)\n      ),\n      args: directiveAST.arguments && makeInputValues(directiveAST.arguments),\n    });\n  }\n\n  function getObjectType(typeAST: TypeDefinition): GraphQLObjectType {\n    const type = typeDefNamed(typeAST.name.value);\n    invariant(\n      type instanceof GraphQLObjectType,\n      'AST must provide object type.'\n    );\n    return (type: any);\n  }\n\n  function produceType(typeAST: Type): GraphQLType {\n    const typeName = getNamedTypeAST(typeAST).name.value;\n    const typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeAST);\n  }\n\n  function produceInputType(typeAST: Type): GraphQLInputType {\n    const type = produceType(typeAST);\n    invariant(isInputType(type), 'Expected Input type.');\n    return (type: any);\n  }\n\n  function produceOutputType(typeAST: Type): GraphQLOutputType {\n    const type = produceType(typeAST);\n    invariant(isOutputType(type), 'Expected Output type.');\n    return (type: any);\n  }\n\n  function produceObjectType(typeAST: Type): GraphQLObjectType {\n    const type = produceType(typeAST);\n    invariant(type instanceof GraphQLObjectType, 'Expected Object type.');\n    return type;\n  }\n\n  function produceInterfaceType(typeAST: Type): GraphQLInterfaceType {\n    const type = produceType(typeAST);\n    invariant(type instanceof GraphQLInterfaceType, 'Expected Object type.');\n    return type;\n  }\n\n  function typeDefNamed(typeName: string): GraphQLNamedType {\n    if (innerTypeMap[typeName]) {\n      return innerTypeMap[typeName];\n    }\n\n    if (!astMap[typeName]) {\n      throw new Error(`Type \"${typeName}\" not found in document.`);\n    }\n\n    const innerTypeDef = makeSchemaDef(astMap[typeName]);\n    if (!innerTypeDef) {\n      throw new Error(`Nothing constructed for \"${typeName}\".`);\n    }\n    innerTypeMap[typeName] = innerTypeDef;\n    return innerTypeDef;\n  }\n\n  function makeSchemaDef(def) {\n    if (!def) {\n      throw new Error('def must be defined');\n    }\n    switch (def.kind) {\n      case OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n      case INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n      case ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n      case UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n      case SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n      case INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n      default:\n        throw new Error(`Type kind \"${def.kind}\" not supported.`);\n    }\n  }\n\n  function makeTypeDef(def: ObjectTypeDefinition) {\n    const typeName = def.name.value;\n    return new GraphQLObjectType({\n      name: typeName,\n      description: getDescription(def),\n      fields: () => makeFieldDefMap(def),\n      interfaces: () => makeImplementedInterfaces(def),\n    });\n  }\n\n  function makeFieldDefMap(\n    def: ObjectTypeDefinition | InterfaceTypeDefinition\n  ) {\n    return keyValMap(\n      def.fields,\n      field => field.name.value,\n      field => ({\n        type: produceOutputType(field.type),\n        description: getDescription(field),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field.directives)\n      })\n    );\n  }\n\n  function makeImplementedInterfaces(def: ObjectTypeDefinition) {\n    return def.interfaces &&\n      def.interfaces.map(iface => produceInterfaceType(iface));\n  }\n\n  function makeInputValues(values: Array<InputValueDefinition>) {\n    return keyValMap(\n      values,\n      value => value.name.value,\n      value => {\n        const type = produceInputType(value.type);\n        return {\n          type,\n          description: getDescription(value),\n          defaultValue: valueFromAST(value.defaultValue, type)\n        };\n      }\n    );\n  }\n\n  function makeInterfaceDef(def: InterfaceTypeDefinition) {\n    const typeName = def.name.value;\n    return new GraphQLInterfaceType({\n      name: typeName,\n      description: getDescription(def),\n      fields: () => makeFieldDefMap(def),\n      resolveType: cannotExecuteSchema,\n    });\n  }\n\n  function makeEnumDef(def: EnumTypeDefinition) {\n    const enumType = new GraphQLEnumType({\n      name: def.name.value,\n      description: getDescription(def),\n      values: keyValMap(\n        def.values,\n        enumValue => enumValue.name.value,\n        enumValue => ({\n          description: getDescription(enumValue),\n          deprecationReason: getDeprecationReason(enumValue.directives)\n        })\n      ),\n    });\n\n    return enumType;\n  }\n\n  function makeUnionDef(def: UnionTypeDefinition) {\n    return new GraphQLUnionType({\n      name: def.name.value,\n      description: getDescription(def),\n      types: def.types.map(t => produceObjectType(t)),\n      resolveType: cannotExecuteSchema,\n    });\n  }\n\n  function makeScalarDef(def: ScalarTypeDefinition) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      description: getDescription(def),\n      serialize: () => null,\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: () => false,\n      parseLiteral: () => false,\n    });\n  }\n\n  function makeInputObjectDef(def: InputObjectTypeDefinition) {\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      description: getDescription(def),\n      fields: () => makeInputValues(def.fields),\n    });\n  }\n}\n\nfunction getDeprecationReason(directives: ?Array<Directive>): ?string {\n  const deprecatedAST = directives && find(\n    directives,\n    directive => directive.name.value === GraphQLDeprecatedDirective.name\n  );\n  if (!deprecatedAST) {\n    return;\n  }\n  const { reason } = getArgumentValues(\n    GraphQLDeprecatedDirective.args,\n    deprecatedAST.arguments\n  );\n  return (reason: any);\n}\n\n/**\n * Given an ast node, returns its string description based on a contiguous\n * block full-line of comments preceding it.\n */\nexport function getDescription(node: { loc?: Location }): ?string {\n  const loc = node.loc;\n  if (!loc) {\n    return;\n  }\n  const comments = [];\n  let minSpaces;\n  let token = loc.startToken.prev;\n  while (\n    token &&\n    token.kind === TokenKind.COMMENT &&\n    token.next && token.prev &&\n    token.line + 1 === token.next.line &&\n    token.line !== token.prev.line\n  ) {\n    const value = String(token.value);\n    const spaces = leadingSpaces(value);\n    if (minSpaces === undefined || spaces < minSpaces) {\n      minSpaces = spaces;\n    }\n    comments.push(value);\n    token = token.prev;\n  }\n  return comments\n    .reverse()\n    .map(comment => comment.slice(minSpaces))\n    .join('\\n');\n}\n\n/**\n * A helper function to build a GraphQLSchema directly from a source\n * document.\n */\nexport function buildSchema(source: string | Source): GraphQLSchema {\n  return buildASTSchema(parse(source));\n}\n\n// Count the number of spaces on the starting side of a string.\nfunction leadingSpaces(str) {\n  let i = 0;\n  for (; i < str.length; i++) {\n    if (str[i] !== ' ') {\n      break;\n    }\n  }\n  return i;\n}\n\nfunction cannotExecuteSchema() {\n  throw new Error(\n    'Generated Schema cannot use Interface or Union types for execution.'\n  );\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}