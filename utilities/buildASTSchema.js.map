{"version":3,"sources":["utilities/buildASTSchema.js"],"names":[],"mappings":"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","file":"utilities/buildASTSchema.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport find from '../jsutils/find';\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { valueFromAST } from './valueFromAST';\n\nimport { getArgumentValues } from '../execution/values';\n\nimport {\n  LIST_TYPE,\n  NON_NULL_TYPE,\n  DOCUMENT,\n  SCHEMA_DEFINITION,\n  SCALAR_TYPE_DEFINITION,\n  OBJECT_TYPE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n  DIRECTIVE_DEFINITION,\n} from '../language/kinds';\n\nimport type {\n  Document,\n  Directive,\n  Type,\n  NamedType,\n  SchemaDefinition,\n  TypeDefinition,\n  ScalarTypeDefinition,\n  ObjectTypeDefinition,\n  InputValueDefinition,\n  InterfaceTypeDefinition,\n  UnionTypeDefinition,\n  EnumTypeDefinition,\n  InputObjectTypeDefinition,\n  DirectiveDefinition,\n} from '../language/ast';\n\nimport {\n  GraphQLSchema,\n  GraphQLScalarType,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n  GraphQLList,\n  GraphQLNonNull,\n} from '../type';\n\nimport {\n  GraphQLDirective,\n  GraphQLSkipDirective,\n  GraphQLIncludeDirective,\n  GraphQLDeprecatedDirective,\n} from '../type/directives';\n\nimport {\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind,\n} from '../type/introspection';\n\nimport type {\n  GraphQLType,\n  GraphQLNamedType\n} from '../type/definition';\n\n\ntype CompositeDefinition =\n  ObjectTypeDefinition |\n  InterfaceTypeDefinition |\n  UnionTypeDefinition;\n\nfunction buildWrappedType(\n  innerType: GraphQLType,\n  inputTypeAST: Type\n): GraphQLType {\n  if (inputTypeAST.kind === LIST_TYPE) {\n    return new GraphQLList(buildWrappedType(innerType, inputTypeAST.type));\n  }\n  if (inputTypeAST.kind === NON_NULL_TYPE) {\n    const wrappedType = buildWrappedType(innerType, inputTypeAST.type);\n    invariant(!(wrappedType instanceof GraphQLNonNull), 'No nesting nonnull.');\n    return new GraphQLNonNull(wrappedType);\n  }\n  return innerType;\n}\n\nfunction getNamedTypeAST(typeAST: Type): NamedType {\n  let namedType = typeAST;\n  while (namedType.kind === LIST_TYPE || namedType.kind === NON_NULL_TYPE) {\n    namedType = namedType.type;\n  }\n  return namedType;\n}\n\n/**\n * This takes the ast of a schema document produced by the parse function in\n * src/language/parser.js.\n *\n * Given that AST it constructs a GraphQLSchema. As constructed\n * they are not particularly useful for non-introspection queries\n * since they have no resolve methods.\n */\nexport function buildASTSchema(ast: Document): GraphQLSchema {\n  if (!ast || ast.kind !== DOCUMENT) {\n    throw new Error('Must provide a document ast.');\n  }\n\n  let schemaDef: ?SchemaDefinition;\n\n  const typeDefs: Array<TypeDefinition> = [];\n  const directiveDefs: Array<DirectiveDefinition> = [];\n  for (let i = 0; i < ast.definitions.length; i++) {\n    const d = ast.definitions[i];\n    switch (d.kind) {\n      case SCHEMA_DEFINITION:\n        if (schemaDef) {\n          throw new Error('Must provide only one schema definition.');\n        }\n        schemaDef = d;\n        break;\n      case SCALAR_TYPE_DEFINITION:\n      case OBJECT_TYPE_DEFINITION:\n      case INTERFACE_TYPE_DEFINITION:\n      case ENUM_TYPE_DEFINITION:\n      case UNION_TYPE_DEFINITION:\n      case INPUT_OBJECT_TYPE_DEFINITION:\n        typeDefs.push(d);\n        break;\n      case DIRECTIVE_DEFINITION:\n        directiveDefs.push(d);\n        break;\n    }\n  }\n\n  if (!schemaDef) {\n    throw new Error('Must provide a schema definition.');\n  }\n\n  let queryTypeName;\n  let mutationTypeName;\n  let subscriptionTypeName;\n  schemaDef.operationTypes.forEach(operationType => {\n    const typeName = operationType.type.name.value;\n    if (operationType.operation === 'query') {\n      if (queryTypeName) {\n        throw new Error('Must provide only one query type in schema.');\n      }\n      queryTypeName = typeName;\n    } else if (operationType.operation === 'mutation') {\n      if (mutationTypeName) {\n        throw new Error('Must provide only one mutation type in schema.');\n      }\n      mutationTypeName = typeName;\n    } else if (operationType.operation === 'subscription') {\n      if (subscriptionTypeName) {\n        throw new Error('Must provide only one subscription type in schema.');\n      }\n      subscriptionTypeName = typeName;\n    }\n  });\n\n  if (!queryTypeName) {\n    throw new Error('Must provide schema definition with query type.');\n  }\n\n  const astMap: {[name: string]: TypeDefinition} =\n    keyMap(typeDefs, d => d.name.value);\n\n  if (!astMap[queryTypeName]) {\n    throw new Error(\n      `Specified query type \"${queryTypeName}\" not found in document.`\n    );\n  }\n\n  if (mutationTypeName && !astMap[mutationTypeName]) {\n    throw new Error(\n      `Specified mutation type \"${mutationTypeName}\" not found in document.`\n    );\n  }\n\n  if (subscriptionTypeName && !astMap[subscriptionTypeName]) {\n    throw new Error(\n      `Specified subscription type \"${\n        subscriptionTypeName}\" not found in document.`\n    );\n  }\n\n  const innerTypeMap = {\n    String: GraphQLString,\n    Int: GraphQLInt,\n    Float: GraphQLFloat,\n    Boolean: GraphQLBoolean,\n    ID: GraphQLID,\n    __Schema,\n    __Directive,\n    __DirectiveLocation,\n    __Type,\n    __Field,\n    __InputValue,\n    __EnumValue,\n    __TypeKind,\n  };\n\n  const types = typeDefs.map(def => typeDefNamed(def.name.value));\n\n  const directives = directiveDefs.map(getDirective);\n\n  // If specified directives were not explicitly declared, add them.\n  if (!directives.some(directive => directive.name === 'skip')) {\n    directives.push(GraphQLSkipDirective);\n  }\n\n  if (!directives.some(directive => directive.name === 'include')) {\n    directives.push(GraphQLIncludeDirective);\n  }\n\n  if (!directives.some(directive => directive.name === 'deprecated')) {\n    directives.push(GraphQLDeprecatedDirective);\n  }\n\n  return new GraphQLSchema({\n    query: getObjectType(astMap[queryTypeName]),\n    mutation: mutationTypeName ? getObjectType(astMap[mutationTypeName]) : null,\n    subscription:\n      subscriptionTypeName ? getObjectType(astMap[subscriptionTypeName]) : null,\n    types,\n    directives,\n  });\n\n  function getDirective(directiveAST: DirectiveDefinition): GraphQLDirective {\n    return new GraphQLDirective({\n      name: directiveAST.name.value,\n      locations: directiveAST.locations.map(node => node.value),\n      args: makeInputValues(directiveAST.arguments),\n    });\n  }\n\n  function getObjectType(typeAST: TypeDefinition): GraphQLObjectType {\n    const type = typeDefNamed(typeAST.name.value);\n    invariant(\n      type instanceof GraphQLObjectType,\n      'AST must provide object type.'\n    );\n    return (type: any);\n  }\n\n  function produceTypeDef(typeAST: Type): GraphQLType {\n    const typeName = getNamedTypeAST(typeAST).name.value;\n    const typeDef = typeDefNamed(typeName);\n    return buildWrappedType(typeDef, typeAST);\n  }\n\n  function typeDefNamed(typeName: string): GraphQLNamedType {\n    if (innerTypeMap[typeName]) {\n      return innerTypeMap[typeName];\n    }\n\n    if (!astMap[typeName]) {\n      throw new Error(`Type \"${typeName}\" not found in document.`);\n    }\n\n    const innerTypeDef = makeSchemaDef(astMap[typeName]);\n    if (!innerTypeDef) {\n      throw new Error(`Nothing constructed for \"${typeName}\".`);\n    }\n    innerTypeMap[typeName] = innerTypeDef;\n    return innerTypeDef;\n  }\n\n  function makeSchemaDef(def) {\n    if (!def) {\n      throw new Error('def must be defined');\n    }\n    switch (def.kind) {\n      case OBJECT_TYPE_DEFINITION:\n        return makeTypeDef(def);\n      case INTERFACE_TYPE_DEFINITION:\n        return makeInterfaceDef(def);\n      case ENUM_TYPE_DEFINITION:\n        return makeEnumDef(def);\n      case UNION_TYPE_DEFINITION:\n        return makeUnionDef(def);\n      case SCALAR_TYPE_DEFINITION:\n        return makeScalarDef(def);\n      case INPUT_OBJECT_TYPE_DEFINITION:\n        return makeInputObjectDef(def);\n      default:\n        throw new Error(`Type kind \"${def.kind}\" not supported.`);\n    }\n  }\n\n  function makeTypeDef(def: ObjectTypeDefinition) {\n    const typeName = def.name.value;\n    const config = {\n      name: typeName,\n      fields: () => makeFieldDefMap(def),\n      interfaces: () => makeImplementedInterfaces(def),\n    };\n    return new GraphQLObjectType(config);\n  }\n\n  function makeFieldDefMap(def: CompositeDefinition) {\n    return keyValMap(\n      def.fields,\n      field => field.name.value,\n      field => ({\n        type: produceTypeDef(field.type),\n        args: makeInputValues(field.arguments),\n        deprecationReason: getDeprecationReason(field.directives)\n      })\n    );\n  }\n\n  function makeImplementedInterfaces(def: ObjectTypeDefinition) {\n    return def.interfaces.map(inter => produceTypeDef(inter));\n  }\n\n  function makeInputValues(values: Array<InputValueDefinition>) {\n    return keyValMap(\n      values,\n      value => value.name.value,\n      value => {\n        const type = produceTypeDef(value.type);\n        return { type, defaultValue: valueFromAST(value.defaultValue, type) };\n      }\n    );\n  }\n\n  function makeInterfaceDef(def: InterfaceTypeDefinition) {\n    const typeName = def.name.value;\n    const config = {\n      name: typeName,\n      resolveType: () => null,\n      fields: () => makeFieldDefMap(def),\n    };\n    return new GraphQLInterfaceType(config);\n  }\n\n  function makeEnumDef(def: EnumTypeDefinition) {\n    const enumType = new GraphQLEnumType({\n      name: def.name.value,\n      values: keyValMap(\n        def.values,\n        enumValue => enumValue.name.value,\n        enumValue => ({\n          deprecationReason: getDeprecationReason(enumValue.directives)\n        })\n      ),\n    });\n\n    return enumType;\n  }\n\n  function makeUnionDef(def: UnionTypeDefinition) {\n    return new GraphQLUnionType({\n      name: def.name.value,\n      resolveType: () => null,\n      types: def.types.map(t => produceTypeDef(t)),\n    });\n  }\n\n  function makeScalarDef(def: ScalarTypeDefinition) {\n    return new GraphQLScalarType({\n      name: def.name.value,\n      serialize: () => null,\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: () => false,\n      parseLiteral: () => false,\n    });\n  }\n\n  function makeInputObjectDef(def: InputObjectTypeDefinition) {\n    return new GraphQLInputObjectType({\n      name: def.name.value,\n      fields: () => makeInputValues(def.fields),\n    });\n  }\n}\n\nfunction getDeprecationReason(directives: ?Array<Directive>): ?string {\n  const deprecatedAST = directives && find(\n    directives,\n    directive => directive.name.value === GraphQLDeprecatedDirective.name\n  );\n  if (!deprecatedAST) {\n    return;\n  }\n  const { reason } = getArgumentValues(\n    GraphQLDeprecatedDirective.args,\n    deprecatedAST.arguments\n  );\n  return (reason: any);\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}