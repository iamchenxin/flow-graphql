{"version":3,"sources":["utilities/separateOperations.js"],"names":[],"mappings":";;;;;QAsBgB;;AAZhB;;;;;;;;AAYO,SAAS,kBAAT,CACL,WADK,EAEkC;;AAEvC,MAAM,aAAa,EAAb,CAFiC;AAGvC,MAAM,WAAqB,OAAO,MAAP,CAAc,IAAd,CAArB,CAHiC;AAIvC,MAAI,oBAAJ;;;AAJuC,qBAOvC,CAAM,WAAN,EAAmB;AACjB,sDAAoB,MAAM;AACxB,iBAAW,IAAX,CAAgB,IAAhB,EADwB;AAExB,iBAAW,OAAO,IAAP,CAAX,CAFwB;KADT;AAKjB,oDAAmB,MAAM;AACvB,iBAAW,KAAK,IAAL,CAAU,KAAV,CADY;KALR;AAQjB,4CAAe,MAAM;AACnB,UAAM,SAAS,KAAK,IAAL,CAAU,KAAV,CADI;AAEnB,OAAC,SAAS,QAAT,MACE,SAAS,QAAT,IAAqB,OAAO,MAAP,CAAc,IAAd,CAArB,CADF,CAAD,CAC8C,MAD9C,IACwD,IADxD,CAFmB;KARJ;GAAnB;;;;AAPuC,MAwBjC,wBAAwB,OAAO,MAAP,CAAc,IAAd,CAAxB,CAxBiC;AAyBvC,aAAW,OAAX,CAAmB,qBAAa;AAC9B,QAAM,gBAAgB,OAAO,SAAP,CAAhB,CADwB;AAE9B,QAAM,eAAe,OAAO,MAAP,CAAc,IAAd,CAAf,CAFwB;AAG9B,kCAA8B,YAA9B,EAA4C,QAA5C,EAAsD,aAAtD,EAH8B;;AAK9B,0BAAsB,aAAtB,IAAuC;AACrC,YAAM,UAAN;AACA,mBAAa,YAAY,WAAZ,CAAwB,MAAxB,CAA+B;eAC1C,QAAQ,SAAR,IACA,IAAI,IAAJ,KAAa,oBAAb,IAAqC,aAAa,IAAI,IAAJ,CAAS,KAAT,CAAlD;OAF0C,CAA5C;KAFF,CAL8B;GAAb,CAAnB,CAzBuC;;AAuCvC,SAAO,qBAAP,CAvCuC;CAFlC;;;;;;;;;;;AA+CP,SAAS,MAAT,CAAgB,SAAhB,EAAwD;AACtD,SAAO,UAAU,IAAV,GAAiB,UAAU,IAAV,CAAe,KAAf,GAAuB,EAAxC,CAD+C;CAAxD;;;;AAMA,SAAS,6BAAT,CACE,SADF,EAEE,QAFF,EAGE,QAHF,EAIQ;AACN,MAAM,gBAAgB,SAAS,QAAT,CAAhB,CADA;AAEN,MAAI,aAAJ,EAAmB;AACjB,WAAO,IAAP,CAAY,aAAZ,EAA2B,OAA3B,CAAmC,kBAAU;AAC3C,UAAI,CAAC,UAAU,MAAV,CAAD,EAAoB;AACtB,kBAAU,MAAV,IAAoB,IAApB,CADsB;AAEtB,sCAA8B,SAA9B,EAAyC,QAAzC,EAAmD,MAAnD,EAFsB;OAAxB;KADiC,CAAnC,CADiB;GAAnB;CANF","file":"utilities/separateOperations.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport { visit } from '../language/visitor';\nimport type {\n  Document,\n  OperationDefinition,\n} from '../language/ast';\n\n/**\n * separateOperations accepts a single AST document which may contain many\n * operations and fragments and returns a collection of AST documents each of\n * which contains a single operation as well the fragment definitions it\n * refers to.\n */\nexport function separateOperations(\n  documentAST: Document\n): { [operationName: string]: Document } {\n\n  const operations = [];\n  const depGraph: DepGraph = Object.create(null);\n  let fromName;\n\n  // Populate the list of operations and build a dependency graph.\n  visit(documentAST, {\n    OperationDefinition(node) {\n      operations.push(node);\n      fromName = opName(node);\n    },\n    FragmentDefinition(node) {\n      fromName = node.name.value;\n    },\n    FragmentSpread(node) {\n      const toName = node.name.value;\n      (depGraph[fromName] ||\n        (depGraph[fromName] = Object.create(null)))[toName] = true;\n    }\n  });\n\n  // For each operation, produce a new synthesized AST which includes only what\n  // is necessary for completing that operation.\n  const separatedDocumentASTs = Object.create(null);\n  operations.forEach(operation => {\n    const operationName = opName(operation);\n    const dependencies = Object.create(null);\n    collectTransitiveDependencies(dependencies, depGraph, operationName);\n\n    separatedDocumentASTs[operationName] = {\n      kind: 'Document',\n      definitions: documentAST.definitions.filter(def =>\n        def === operation ||\n        def.kind === 'FragmentDefinition' && dependencies[def.name.value]\n      )\n    };\n  });\n\n  return separatedDocumentASTs;\n}\n\ntype DepGraph = {[from: string]: {[to: string]: boolean}};\n\n// Provides the empty string for anonymous operations.\nfunction opName(operation: OperationDefinition): string {\n  return operation.name ? operation.name.value : '';\n}\n\n// From a dependency graph, collects a list of transitive dependencies by\n// recursing through a dependency graph.\nfunction collectTransitiveDependencies(\n  collected: {[key: string]: boolean},\n  depGraph: DepGraph,\n  fromName: string\n): void {\n  const immediateDeps = depGraph[fromName];\n  if (immediateDeps) {\n    Object.keys(immediateDeps).forEach(toName => {\n      if (!collected[toName]) {\n        collected[toName] = true;\n        collectTransitiveDependencies(collected, depGraph, toName);\n      }\n    });\n  }\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}