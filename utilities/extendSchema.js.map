{"version":3,"sources":["utilities/extendSchema.js"],"names":[],"mappings":"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","file":"utilities/extendSchema.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport invariant from '../jsutils/invariant';\nimport keyMap from '../jsutils/keyMap';\nimport keyValMap from '../jsutils/keyValMap';\nimport { getDescription } from './buildASTSchema';\nimport { valueFromAST } from './valueFromAST';\nimport { GraphQLError } from '../error/GraphQLError';\nimport { GraphQLSchema } from '../type/schema';\n\nimport {\n  GraphQLList,\n  GraphQLNonNull,\n  GraphQLObjectType,\n  GraphQLInterfaceType,\n  GraphQLUnionType,\n  GraphQLScalarType,\n  GraphQLEnumType,\n  GraphQLInputObjectType,\n  isInputType,\n  isOutputType,\n} from '../type/definition';\n\nimport {\n  GraphQLDirective,\n} from '../type/directives';\n\nimport {\n  __Schema,\n  __Directive,\n  __DirectiveLocation,\n  __Type,\n  __Field,\n  __InputValue,\n  __EnumValue,\n  __TypeKind,\n} from '../type/introspection';\n\nimport {\n  GraphQLString,\n  GraphQLInt,\n  GraphQLFloat,\n  GraphQLBoolean,\n  GraphQLID,\n} from '../type/scalars';\n\nimport {\n  DOCUMENT,\n  LIST_TYPE,\n  NON_NULL_TYPE,\n  OBJECT_TYPE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  SCALAR_TYPE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n  TYPE_EXTENSION_DEFINITION,\n  DIRECTIVE_DEFINITION,\n} from '../language/kinds';\n\nimport type {\n  GraphQLType,\n  GraphQLNamedType,\n  GraphQLInputType,\n  GraphQLOutputType,\n} from '../type/definition';\n\nimport type {\n  DirectiveLocationEnum\n} from '../type/directives';\n\nimport type {\n  Document,\n  InputValueDefinition,\n  Type,\n  NamedType,\n  TypeDefinition,\n  ObjectTypeDefinition,\n  InterfaceTypeDefinition,\n  UnionTypeDefinition,\n  ScalarTypeDefinition,\n  EnumTypeDefinition,\n  InputObjectTypeDefinition,\n  DirectiveDefinition,\n} from '../language/ast';\n\n\n/**\n * Produces a new schema given an existing schema and a document which may\n * contain GraphQL type extensions and definitions. The original schema will\n * remain unaltered.\n *\n * Because a schema represents a graph of references, a schema cannot be\n * extended without effectively making an entire copy. We do not know until it's\n * too late if subgraphs remain unchanged.\n *\n * This algorithm copies the provided schema, applying extensions while\n * producing the copy. The original schema remains unaltered.\n */\nexport function extendSchema(\n  schema: GraphQLSchema,\n  documentAST: Document\n): GraphQLSchema {\n  invariant(\n    schema instanceof GraphQLSchema,\n    'Must provide valid GraphQLSchema'\n  );\n\n  invariant(\n    documentAST && documentAST.kind === DOCUMENT,\n    'Must provide valid Document AST'\n  );\n\n  // Collect the type definitions and extensions found in the document.\n  const typeDefinitionMap = {};\n  const typeExtensionsMap = {};\n\n  // New directives and types are separate because a directives and types can\n  // have the same name. For example, a type named \"skip\".\n  const directiveDefinitions : Array<DirectiveDefinition> = [];\n\n  for (let i = 0; i < documentAST.definitions.length; i++) {\n    const def = documentAST.definitions[i];\n    switch (def.kind) {\n      case OBJECT_TYPE_DEFINITION:\n      case INTERFACE_TYPE_DEFINITION:\n      case ENUM_TYPE_DEFINITION:\n      case UNION_TYPE_DEFINITION:\n      case SCALAR_TYPE_DEFINITION:\n      case INPUT_OBJECT_TYPE_DEFINITION:\n        // Sanity check that none of the defined types conflict with the\n        // schema's existing types.\n        const typeName = def.name.value;\n        if (schema.getType(typeName)) {\n          throw new GraphQLError(\n            `Type \"${typeName}\" already exists in the schema. It cannot also ` +\n            'be defined in this type definition.',\n            [ def ]\n          );\n        }\n        typeDefinitionMap[typeName] = def;\n        break;\n      case TYPE_EXTENSION_DEFINITION:\n        // Sanity check that this type extension exists within the\n        // schema's existing types.\n        const extendedTypeName = def.definition.name.value;\n        const existingType = schema.getType(extendedTypeName);\n        if (!existingType) {\n          throw new GraphQLError(\n            `Cannot extend type \"${extendedTypeName}\" because it does not ` +\n            'exist in the existing schema.',\n            [ def.definition ]\n          );\n        }\n        if (!(existingType instanceof GraphQLObjectType)) {\n          throw new GraphQLError(\n            `Cannot extend non-object type \"${extendedTypeName}\".`,\n            [ def.definition ]\n          );\n        }\n        let extensions = typeExtensionsMap[extendedTypeName];\n        if (extensions) {\n          extensions.push(def);\n        } else {\n          extensions = [ def ];\n        }\n        typeExtensionsMap[extendedTypeName] = extensions;\n        break;\n      case DIRECTIVE_DEFINITION:\n        const directiveName = def.name.value;\n        const existingDirective = schema.getDirective(directiveName);\n        if (existingDirective) {\n          throw new GraphQLError(\n            `Directive \"${directiveName}\" already exists in the schema. It ` +\n            'cannot be redefined.',\n            [ def ]\n          );\n        }\n        directiveDefinitions.push(def);\n        break;\n    }\n  }\n\n  // If this document contains no new types, extensions, or directives then\n  // return the same unmodified GraphQLSchema instance.\n  if (Object.keys(typeExtensionsMap).length === 0 &&\n      Object.keys(typeDefinitionMap).length === 0 &&\n      directiveDefinitions.length === 0) {\n    return schema;\n  }\n\n  // A cache to use to store the actual GraphQLType definition objects by name.\n  // Initialize to the GraphQL built in scalars and introspection types. All\n  // functions below are inline so that this type def cache is within the scope\n  // of the closure.\n  const typeDefCache = {\n    String: GraphQLString,\n    Int: GraphQLInt,\n    Float: GraphQLFloat,\n    Boolean: GraphQLBoolean,\n    ID: GraphQLID,\n    __Schema,\n    __Directive,\n    __DirectiveLocation,\n    __Type,\n    __Field,\n    __InputValue,\n    __EnumValue,\n    __TypeKind,\n  };\n\n  // Get the root Query, Mutation, and Subscription object types.\n  const queryType = getTypeFromDef(schema.getQueryType());\n\n  const existingMutationType = schema.getMutationType();\n  const mutationType = existingMutationType ?\n    getTypeFromDef(existingMutationType) :\n    null;\n\n  const existingSubscriptionType = schema.getSubscriptionType();\n  const subscriptionType = existingSubscriptionType ?\n    getTypeFromDef(existingSubscriptionType) :\n    null;\n\n  // Iterate through all types, getting the type definition for each, ensuring\n  // that any type not directly referenced by a field will get created.\n  const typeMap = schema.getTypeMap();\n  const types = Object.keys(typeMap).map(typeName =>\n    getTypeFromDef(typeMap[typeName])\n  );\n\n  // Do the same with new types, appending to the list of defined types.\n  Object.keys(typeDefinitionMap).forEach(typeName => {\n    types.push(getTypeFromAST(typeDefinitionMap[typeName]));\n  });\n\n  // Then produce and return a Schema with these types.\n  return new GraphQLSchema({\n    query: queryType,\n    mutation: mutationType,\n    subscription: subscriptionType,\n    types,\n    directives: getMergedDirectives(),\n  });\n\n  // Below are functions used for producing this schema that have closed over\n  // this scope and have access to the schema, cache, and newly defined types.\n\n  function getMergedDirectives(): Array<GraphQLDirective> {\n    const existingDirectives = schema.getDirectives();\n    invariant(existingDirectives, 'schema must have default directives');\n\n    const newDirectives = directiveDefinitions.map(directiveAST =>\n      getDirective(directiveAST)\n    );\n    return existingDirectives.concat(newDirectives);\n  }\n\n  function getTypeFromDef<T: GraphQLNamedType>(typeDef: T): T {\n    const type = _getNamedType(typeDef.name);\n    invariant(type, 'Missing type from schema');\n    return (type: any);\n  }\n\n  function getTypeFromAST(astNode: NamedType): GraphQLNamedType {\n    const type = _getNamedType(astNode.name.value);\n    if (!type) {\n      throw new GraphQLError(\n        `Unknown type: \"${astNode.name.value}\". Ensure that this type exists ` +\n        'either in the original schema, or is added in a type definition.',\n        [ astNode ]\n      );\n    }\n    return type;\n  }\n\n  function getObjectTypeFromAST(astNode: NamedType): GraphQLObjectType {\n    const type = getTypeFromAST(astNode);\n    invariant(type instanceof GraphQLObjectType, 'Must be Object type.');\n    return type;\n  }\n\n  function getInterfaceTypeFromAST(astNode: NamedType): GraphQLInterfaceType {\n    const type = getTypeFromAST(astNode);\n    invariant(type instanceof GraphQLInterfaceType, 'Must be Interface type.');\n    return type;\n  }\n\n  function getInputTypeFromAST(astNode: NamedType): GraphQLInputType {\n    const type = getTypeFromAST(astNode);\n    invariant(isInputType(type), 'Must be Input type.');\n    return (type: any);\n  }\n\n  function getOutputTypeFromAST(astNode: NamedType): GraphQLOutputType {\n    const type = getTypeFromAST(astNode);\n    invariant(isOutputType(type), 'Must be Output type.');\n    return (type: any);\n  }\n\n  // Given a name, returns a type from either the existing schema or an\n  // added type.\n  function _getNamedType(typeName: string): ?GraphQLNamedType {\n    const cachedTypeDef = typeDefCache[typeName];\n    if (cachedTypeDef) {\n      return cachedTypeDef;\n    }\n\n    const existingType = schema.getType(typeName);\n    if (existingType) {\n      const typeDef = extendType(existingType);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n\n    const typeAST = typeDefinitionMap[typeName];\n    if (typeAST) {\n      const typeDef = buildType(typeAST);\n      typeDefCache[typeName] = typeDef;\n      return typeDef;\n    }\n  }\n\n  // Given a type's introspection result, construct the correct\n  // GraphQLType instance.\n  function extendType(type: GraphQLNamedType): GraphQLNamedType {\n    if (type instanceof GraphQLObjectType) {\n      return extendObjectType(type);\n    }\n    if (type instanceof GraphQLInterfaceType) {\n      return extendInterfaceType(type);\n    }\n    if (type instanceof GraphQLUnionType) {\n      return extendUnionType(type);\n    }\n    return type;\n  }\n\n  function extendObjectType(type: GraphQLObjectType): GraphQLObjectType {\n    return new GraphQLObjectType({\n      name: type.name,\n      description: type.description,\n      interfaces: () => extendImplementedInterfaces(type),\n      fields: () => extendFieldMap(type),\n      isTypeOf: type.isTypeOf,\n    });\n  }\n\n  function extendInterfaceType(\n    type: GraphQLInterfaceType\n  ): GraphQLInterfaceType {\n    return new GraphQLInterfaceType({\n      name: type.name,\n      description: type.description,\n      fields: () => extendFieldMap(type),\n      resolveType: type.resolveType,\n    });\n  }\n\n  function extendUnionType(type: GraphQLUnionType): GraphQLUnionType {\n    return new GraphQLUnionType({\n      name: type.name,\n      description: type.description,\n      types: type.getTypes().map(getTypeFromDef),\n      resolveType: type.resolveType,\n    });\n  }\n\n  function extendImplementedInterfaces(\n    type: GraphQLObjectType\n  ): Array<GraphQLInterfaceType> {\n    const interfaces = type.getInterfaces().map(getTypeFromDef);\n\n    // If there are any extensions to the interfaces, apply those here.\n    const extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(extension => {\n        extension.definition.interfaces.forEach(namedType => {\n          const interfaceName = namedType.name.value;\n          if (interfaces.some(def => def.name === interfaceName)) {\n            throw new GraphQLError(\n              `Type \"${type.name}\" already implements \"${interfaceName}\". ` +\n              'It cannot also be implemented in this type extension.',\n              [ namedType ]\n            );\n          }\n          interfaces.push(getInterfaceTypeFromAST(namedType));\n        });\n      });\n    }\n\n    return interfaces;\n  }\n\n  function extendFieldMap(type: GraphQLObjectType | GraphQLInterfaceType) {\n    const newFieldMap = {};\n    const oldFieldMap = type.getFields();\n    Object.keys(oldFieldMap).forEach(fieldName => {\n      const field = oldFieldMap[fieldName];\n      newFieldMap[fieldName] = {\n        description: field.description,\n        deprecationReason: field.deprecationReason,\n        type: extendFieldType(field.type),\n        args: keyMap(field.args, arg => arg.name),\n        resolve: field.resolve,\n      };\n    });\n\n    // If there are any extensions to the fields, apply those here.\n    const extensions = typeExtensionsMap[type.name];\n    if (extensions) {\n      extensions.forEach(extension => {\n        extension.definition.fields.forEach(field => {\n          const fieldName = field.name.value;\n          if (oldFieldMap[fieldName]) {\n            throw new GraphQLError(\n              `Field \"${type.name}.${fieldName}\" already exists in the ` +\n              'schema. It cannot also be defined in this type extension.',\n              [ field ]\n            );\n          }\n          newFieldMap[fieldName] = {\n            description: getDescription(field),\n            type: buildOutputFieldType(field.type),\n            args: buildInputValues(field.arguments),\n          };\n        });\n      });\n    }\n\n    return newFieldMap;\n  }\n\n  function extendFieldType<T: GraphQLType>(typeDef: T): T {\n    if (typeDef instanceof GraphQLList) {\n      return (new GraphQLList(extendFieldType(typeDef.ofType)): any);\n    }\n    if (typeDef instanceof GraphQLNonNull) {\n      return (new GraphQLNonNull(extendFieldType(typeDef.ofType)): any);\n    }\n    return getTypeFromDef(typeDef);\n  }\n\n  function buildType(typeAST: TypeDefinition): GraphQLNamedType {\n    switch (typeAST.kind) {\n      case OBJECT_TYPE_DEFINITION: return buildObjectType(typeAST);\n      case INTERFACE_TYPE_DEFINITION: return buildInterfaceType(typeAST);\n      case UNION_TYPE_DEFINITION: return buildUnionType(typeAST);\n      case SCALAR_TYPE_DEFINITION: return buildScalarType(typeAST);\n      case ENUM_TYPE_DEFINITION: return buildEnumType(typeAST);\n      case INPUT_OBJECT_TYPE_DEFINITION: return buildInputObjectType(typeAST);\n    }\n    throw new TypeError('Unknown type kind ' + typeAST.kind);\n  }\n\n  function buildObjectType(typeAST: ObjectTypeDefinition): GraphQLObjectType {\n    return new GraphQLObjectType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      interfaces: () => buildImplementedInterfaces(typeAST),\n      fields: () => buildFieldMap(typeAST),\n    });\n  }\n\n  function buildInterfaceType(typeAST: InterfaceTypeDefinition) {\n    return new GraphQLInterfaceType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      fields: () => buildFieldMap(typeAST),\n      resolveType: cannotExecuteExtendedSchema,\n    });\n  }\n\n  function buildUnionType(typeAST: UnionTypeDefinition) {\n    return new GraphQLUnionType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      types: typeAST.types.map(getObjectTypeFromAST),\n      resolveType: cannotExecuteExtendedSchema,\n    });\n  }\n\n  function buildScalarType(typeAST: ScalarTypeDefinition) {\n    return new GraphQLScalarType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      serialize: id => id,\n      // Note: validation calls the parse functions to determine if a\n      // literal value is correct. Returning null would cause use of custom\n      // scalars to always fail validation. Returning false causes them to\n      // always pass validation.\n      parseValue: () => false,\n      parseLiteral: () => false,\n    });\n  }\n\n  function buildEnumType(typeAST: EnumTypeDefinition) {\n    return new GraphQLEnumType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      values: keyValMap(typeAST.values, v => v.name.value, () => ({})),\n    });\n  }\n\n  function buildInputObjectType(typeAST: InputObjectTypeDefinition) {\n    return new GraphQLInputObjectType({\n      name: typeAST.name.value,\n      description: getDescription(typeAST),\n      fields: () => buildInputValues(typeAST.fields),\n    });\n  }\n\n  function getDirective(\n    directiveAST: DirectiveDefinition\n  ): GraphQLDirective {\n    return new GraphQLDirective({\n      name: directiveAST.name.value,\n      locations: directiveAST.locations.map(\n        node => ((node.value: any): DirectiveLocationEnum)\n      ),\n      args: directiveAST.arguments && buildInputValues(directiveAST.arguments),\n    });\n  }\n\n  function buildImplementedInterfaces(typeAST: ObjectTypeDefinition) {\n    return typeAST.interfaces &&\n      typeAST.interfaces.map(getInterfaceTypeFromAST);\n  }\n\n  function buildFieldMap(typeAST) {\n    return keyValMap(\n      typeAST.fields,\n      field => field.name.value,\n      field => ({\n        type: buildOutputFieldType(field.type),\n        description: getDescription(field),\n        args: buildInputValues(field.arguments),\n      })\n    );\n  }\n\n  function buildInputValues(values: Array<InputValueDefinition>) {\n    return keyValMap(\n      values,\n      value => value.name.value,\n      value => {\n        const type = buildInputFieldType(value.type);\n        return {\n          type,\n          description: getDescription(value),\n          defaultValue: valueFromAST(value.defaultValue, type)\n        };\n      }\n    );\n  }\n\n  function buildInputFieldType(typeAST: Type): GraphQLInputType {\n    if (typeAST.kind === LIST_TYPE) {\n      return new GraphQLList(buildInputFieldType(typeAST.type));\n    }\n    if (typeAST.kind === NON_NULL_TYPE) {\n      const nullableType = buildInputFieldType(typeAST.type);\n      invariant(!(nullableType instanceof GraphQLNonNull), 'Must be nullable');\n      return new GraphQLNonNull(nullableType);\n    }\n    return getInputTypeFromAST(typeAST);\n  }\n\n  function buildOutputFieldType(typeAST: Type): GraphQLOutputType {\n    if (typeAST.kind === LIST_TYPE) {\n      return new GraphQLList(buildOutputFieldType(typeAST.type));\n    }\n    if (typeAST.kind === NON_NULL_TYPE) {\n      const nullableType = buildOutputFieldType(typeAST.type);\n      invariant(!(nullableType instanceof GraphQLNonNull), 'Must be nullable');\n      return new GraphQLNonNull(nullableType);\n    }\n    return getOutputTypeFromAST(typeAST);\n  }\n}\n\nfunction cannotExecuteExtendedSchema() {\n  throw new Error(\n    'Extended Schema cannot use Interface or Union types for execution.'\n  );\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}