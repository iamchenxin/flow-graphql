{"version":3,"sources":["language/parser.js"],"names":[],"mappings":"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","file":"language/parser.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport { Source } from './source';\nimport { syntaxError } from '../error';\nimport { lex, TokenKind, getTokenKindDesc, getTokenDesc } from './lexer';\nimport type { Token } from './lexer';\nimport type {\n  Name,\n  Variable,\n\n  Document,\n  Definition,\n  OperationDefinition,\n  OperationType,\n  VariableDefinition,\n  SelectionSet,\n  Selection,\n  Field,\n  Argument,\n\n  FragmentSpread,\n  InlineFragment,\n  FragmentDefinition,\n\n  Value,\n  ListValue,\n  ObjectValue,\n  ObjectField,\n\n  Directive,\n\n  Type,\n  NamedType,\n  ListType,\n  NonNullType,\n\n  TypeSystemDefinition,\n\n  SchemaDefinition,\n  OperationTypeDefinition,\n\n  ScalarTypeDefinition,\n  ObjectTypeDefinition,\n  FieldDefinition,\n  InputValueDefinition,\n  InterfaceTypeDefinition,\n  UnionTypeDefinition,\n  EnumTypeDefinition,\n  EnumValueDefinition,\n  InputObjectTypeDefinition,\n\n  TypeExtensionDefinition,\n\n  DirectiveDefinition,\n} from './ast';\n\nimport {\n  NAME,\n  VARIABLE,\n\n  DOCUMENT,\n  OPERATION_DEFINITION,\n  VARIABLE_DEFINITION,\n  SELECTION_SET,\n  FIELD,\n  ARGUMENT,\n\n  FRAGMENT_SPREAD,\n  INLINE_FRAGMENT,\n  FRAGMENT_DEFINITION,\n\n  INT,\n  FLOAT,\n  STRING,\n  BOOLEAN,\n  ENUM,\n  LIST,\n  OBJECT,\n  OBJECT_FIELD,\n\n  DIRECTIVE,\n\n  NAMED_TYPE,\n  LIST_TYPE,\n  NON_NULL_TYPE,\n\n  SCHEMA_DEFINITION,\n  OPERATION_TYPE_DEFINITION,\n\n  SCALAR_TYPE_DEFINITION,\n  OBJECT_TYPE_DEFINITION,\n  FIELD_DEFINITION,\n  INPUT_VALUE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  ENUM_VALUE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n\n  TYPE_EXTENSION_DEFINITION,\n\n  DIRECTIVE_DEFINITION,\n} from './kinds';\n\n\n/**\n * Configuration options to control parser behavior\n */\nexport type ParseOptions = {\n  /**\n   * By default, the parser creates AST nodes that know the location\n   * in the source that they correspond to. This configuration flag\n   * disables that behavior for performance or testing.\n   */\n  noLocation?: boolean,\n\n  /**\n   * By default, the parser creates AST nodes that contain a reference\n   * to the source that they were created from. This configuration flag\n   * disables that behavior for performance or testing.\n   */\n  noSource?: boolean,\n}\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(\n  source: Source | string,\n  options?: ParseOptions\n): Document {\n  const sourceObj = source instanceof Source ? source : new Source(source);\n  const parser = makeParser(sourceObj, options || {});\n  return parseDocument(parser);\n}\n\n/**\n * Given a string containing a GraphQL value, parse the AST for that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n */\nexport function parseValue(\n  source: Source | string,\n  options?: ParseOptions\n): Value {\n  const sourceObj = source instanceof Source ? source : new Source(source);\n  const parser = makeParser(sourceObj, options || {});\n  return parseValueLiteral(parser, false);\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(parser: Parser): Name {\n  const token = expect(parser, TokenKind.NAME);\n  return {\n    kind: NAME,\n    value: ((token.value: any): string),\n    loc: loc(parser, token.start)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(parser: Parser): Document {\n  const start = parser.token.start;\n\n  const definitions = [];\n  do {\n    definitions.push(parseDefinition(parser));\n  } while (!skip(parser, TokenKind.EOF));\n\n  return {\n    kind: DOCUMENT,\n    definitions,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(parser: Parser): Definition {\n  if (peek(parser, TokenKind.BRACE_L)) {\n    return parseOperationDefinition(parser);\n  }\n\n  if (peek(parser, TokenKind.NAME)) {\n    switch (parser.token.value) {\n      case 'query':\n      case 'mutation':\n      // Note: subscription is an experimental non-spec addition.\n      case 'subscription': return parseOperationDefinition(parser);\n\n      case 'fragment': return parseFragmentDefinition(parser);\n\n      // Note: the Type System IDL is an experimental non-spec addition.\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive': return parseTypeSystemDefinition(parser);\n    }\n  }\n\n  throw unexpected(parser);\n}\n\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(parser: Parser): OperationDefinition {\n  const start = parser.token.start;\n  if (peek(parser, TokenKind.BRACE_L)) {\n    return {\n      kind: OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(parser),\n      loc: loc(parser, start)\n    };\n  }\n  const operation = parseOperationType(parser);\n  let name;\n  if (peek(parser, TokenKind.NAME)) {\n    name = parseName(parser);\n  }\n  return {\n    kind: OPERATION_DEFINITION,\n    operation,\n    name,\n    variableDefinitions: parseVariableDefinitions(parser),\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(parser: Parser): OperationType {\n  const operationToken = expect(parser, TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query': return 'query';\n    case 'mutation': return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n    case 'subscription': return 'subscription';\n  }\n\n  throw unexpected(parser, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(parser: Parser): Array<VariableDefinition> {\n  return peek(parser, TokenKind.PAREN_L) ?\n    many(\n      parser,\n      TokenKind.PAREN_L,\n      parseVariableDefinition,\n      TokenKind.PAREN_R\n    ) :\n    [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(parser: Parser): VariableDefinition {\n  const start = parser.token.start;\n  return {\n    kind: VARIABLE_DEFINITION,\n    variable: parseVariable(parser),\n    type: (expect(parser, TokenKind.COLON), parseType(parser)),\n    defaultValue:\n      skip(parser, TokenKind.EQUALS) ? parseValueLiteral(parser, true) : null,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(parser: Parser): Variable {\n  const start = parser.token.start;\n  expect(parser, TokenKind.DOLLAR);\n  return {\n    kind: VARIABLE,\n    name: parseName(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(parser: Parser): SelectionSet {\n  const start = parser.token.start;\n  return {\n    kind: SELECTION_SET,\n    selections:\n      many(parser, TokenKind.BRACE_L, parseSelection, TokenKind.BRACE_R),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(parser: Parser): Selection {\n  return peek(parser, TokenKind.SPREAD) ?\n    parseFragment(parser) :\n    parseField(parser);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(parser: Parser): Field {\n  const start = parser.token.start;\n\n  const nameOrAlias = parseName(parser);\n  let alias;\n  let name;\n  if (skip(parser, TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(parser);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: FIELD,\n    alias,\n    name,\n    arguments: parseArguments(parser),\n    directives: parseDirectives(parser),\n    selectionSet:\n      peek(parser, TokenKind.BRACE_L) ? parseSelectionSet(parser) : null,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * Arguments : ( Argument+ )\n */\nfunction parseArguments(parser: Parser): Array<Argument> {\n  return peek(parser, TokenKind.PAREN_L) ?\n    many(parser, TokenKind.PAREN_L, parseArgument, TokenKind.PAREN_R) :\n    [];\n}\n\n/**\n * Argument : Name : Value\n */\nfunction parseArgument(parser: Parser): Argument {\n  const start = parser.token.start;\n  return {\n    kind: ARGUMENT,\n    name: parseName(parser),\n    value: (expect(parser, TokenKind.COLON), parseValueLiteral(parser, false)),\n    loc: loc(parser, start)\n  };\n}\n\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(parser: Parser): FragmentSpread | InlineFragment {\n  const start = parser.token.start;\n  expect(parser, TokenKind.SPREAD);\n  if (peek(parser, TokenKind.NAME) && parser.token.value !== 'on') {\n    return {\n      kind: FRAGMENT_SPREAD,\n      name: parseFragmentName(parser),\n      directives: parseDirectives(parser),\n      loc: loc(parser, start)\n    };\n  }\n  let typeCondition = null;\n  if (parser.token.value === 'on') {\n    advance(parser);\n    typeCondition = parseNamedType(parser);\n  }\n  return {\n    kind: INLINE_FRAGMENT,\n    typeCondition,\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(parser: Parser): FragmentDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'fragment');\n  return {\n    kind: FRAGMENT_DEFINITION,\n    name: parseFragmentName(parser),\n    typeCondition: (expectKeyword(parser, 'on'), parseNamedType(parser)),\n    directives: parseDirectives(parser),\n    selectionSet: parseSelectionSet(parser),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(parser: Parser): Name {\n  if (parser.token.value === 'on') {\n    throw unexpected(parser);\n  }\n  return parseName(parser);\n}\n\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(parser: Parser, isConst: boolean): Value {\n  const token = parser.token;\n  switch (token.kind) {\n    case TokenKind.BRACKET_L:\n      return parseList(parser, isConst);\n    case TokenKind.BRACE_L:\n      return parseObject(parser, isConst);\n    case TokenKind.INT:\n      advance(parser);\n      return {\n        kind: INT,\n        value: ((token.value: any): string),\n        loc: loc(parser, token.start)\n      };\n    case TokenKind.FLOAT:\n      advance(parser);\n      return {\n        kind: FLOAT,\n        value: ((token.value: any): string),\n        loc: loc(parser, token.start)\n      };\n    case TokenKind.STRING:\n      advance(parser);\n      return {\n        kind: STRING,\n        value: ((token.value: any): string),\n        loc: loc(parser, token.start)\n      };\n    case TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        advance(parser);\n        return {\n          kind: BOOLEAN,\n          value: token.value === 'true',\n          loc: loc(parser, token.start)\n        };\n      } else if (token.value !== 'null') {\n        advance(parser);\n        return {\n          kind: ENUM,\n          value: ((token.value: any): string),\n          loc: loc(parser, token.start)\n        };\n      }\n      break;\n    case TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(parser);\n      }\n      break;\n  }\n  throw unexpected(parser);\n}\n\nexport function parseConstValue(parser: Parser): Value {\n  return parseValueLiteral(parser, true);\n}\n\nfunction parseValueValue(parser: Parser): Value {\n  return parseValueLiteral(parser, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(parser: Parser, isConst: boolean): ListValue {\n  const start = parser.token.start;\n  const item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: LIST,\n    values: any(parser, TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(parser: Parser, isConst: boolean): ObjectValue {\n  const start = parser.token.start;\n  expect(parser, TokenKind.BRACE_L);\n  const fields = [];\n  while (!skip(parser, TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(parser, isConst));\n  }\n  return {\n    kind: OBJECT,\n    fields,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(parser: Parser, isConst: boolean): ObjectField {\n  const start = parser.token.start;\n  return {\n    kind: OBJECT_FIELD,\n    name: parseName(parser),\n    value:\n      (expect(parser, TokenKind.COLON), parseValueLiteral(parser, isConst)),\n    loc: loc(parser, start)\n  };\n}\n\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\nfunction parseDirectives(parser: Parser): Array<Directive> {\n  const directives = [];\n  while (peek(parser, TokenKind.AT)) {\n    directives.push(parseDirective(parser));\n  }\n  return directives;\n}\n\n/**\n * Directive : @ Name Arguments?\n */\nfunction parseDirective(parser: Parser): Directive {\n  const start = parser.token.start;\n  expect(parser, TokenKind.AT);\n  return {\n    kind: DIRECTIVE,\n    name: parseName(parser),\n    arguments: parseArguments(parser),\n    loc: loc(parser, start)\n  };\n}\n\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nexport function parseType(parser: Parser): Type {\n  const start = parser.token.start;\n  let type;\n  if (skip(parser, TokenKind.BRACKET_L)) {\n    type = parseType(parser);\n    expect(parser, TokenKind.BRACKET_R);\n    type = ({\n      kind: LIST_TYPE,\n      type,\n      loc: loc(parser, start)\n    }: ListType);\n  } else {\n    type = parseNamedType(parser);\n  }\n  if (skip(parser, TokenKind.BANG)) {\n    return ({\n      kind: NON_NULL_TYPE,\n      type,\n      loc: loc(parser, start)\n    }: NonNullType);\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nexport function parseNamedType(parser: Parser): NamedType {\n  const start = parser.token.start;\n  return {\n    kind: NAMED_TYPE,\n    name: parseName(parser),\n    loc: loc(parser, start)\n  };\n}\n\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(parser: Parser): TypeSystemDefinition {\n  if (peek(parser, TokenKind.NAME)) {\n    switch (parser.token.value) {\n      case 'schema': return parseSchemaDefinition(parser);\n      case 'scalar': return parseScalarTypeDefinition(parser);\n      case 'type': return parseObjectTypeDefinition(parser);\n      case 'interface': return parseInterfaceTypeDefinition(parser);\n      case 'union': return parseUnionTypeDefinition(parser);\n      case 'enum': return parseEnumTypeDefinition(parser);\n      case 'input': return parseInputObjectTypeDefinition(parser);\n      case 'extend': return parseTypeExtensionDefinition(parser);\n      case 'directive': return parseDirectiveDefinition(parser);\n    }\n  }\n\n  throw unexpected(parser);\n}\n\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseSchemaDefinition(parser: Parser): SchemaDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'schema');\n  const directives = parseDirectives(parser);\n  const operationTypes = many(\n    parser,\n    TokenKind.BRACE_L,\n    parseOperationTypeDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: SCHEMA_DEFINITION,\n    directives,\n    operationTypes,\n    loc: loc(parser, start),\n  };\n}\n\nfunction parseOperationTypeDefinition(parser: Parser): OperationTypeDefinition {\n  const start = parser.token.start;\n  const operation = parseOperationType(parser);\n  expect(parser, TokenKind.COLON);\n  const type = parseNamedType(parser);\n  return {\n    kind: OPERATION_TYPE_DEFINITION,\n    operation,\n    type,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\nfunction parseScalarTypeDefinition(parser: Parser): ScalarTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'scalar');\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  return {\n    kind: SCALAR_TYPE_DEFINITION,\n    name,\n    directives,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\nfunction parseObjectTypeDefinition(parser: Parser): ObjectTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'type');\n  const name = parseName(parser);\n  const interfaces = parseImplementsInterfaces(parser);\n  const directives = parseDirectives(parser);\n  const fields = any(\n    parser,\n    TokenKind.BRACE_L,\n    parseFieldDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: OBJECT_TYPE_DEFINITION,\n    name,\n    interfaces,\n    directives,\n    fields,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(parser: Parser): Array<NamedType> {\n  const types = [];\n  if (parser.token.value === 'implements') {\n    advance(parser);\n    do {\n      types.push(parseNamedType(parser));\n    } while (peek(parser, TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\nfunction parseFieldDefinition(parser: Parser): FieldDefinition {\n  const start = parser.token.start;\n  const name = parseName(parser);\n  const args = parseArgumentDefs(parser);\n  expect(parser, TokenKind.COLON);\n  const type = parseType(parser);\n  const directives = parseDirectives(parser);\n  return {\n    kind: FIELD_DEFINITION,\n    name,\n    arguments: args,\n    type,\n    directives,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(parser: Parser): Array<InputValueDefinition> {\n  if (!peek(parser, TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(parser, TokenKind.PAREN_L, parseInputValueDef, TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\nfunction parseInputValueDef(parser: Parser): InputValueDefinition {\n  const start = parser.token.start;\n  const name = parseName(parser);\n  expect(parser, TokenKind.COLON);\n  const type = parseType(parser);\n  let defaultValue = null;\n  if (skip(parser, TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(parser);\n  }\n  const directives = parseDirectives(parser);\n  return {\n    kind: INPUT_VALUE_DEFINITION,\n    name,\n    type,\n    defaultValue,\n    directives,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\nfunction parseInterfaceTypeDefinition(parser: Parser): InterfaceTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'interface');\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  const fields = any(\n    parser,\n    TokenKind.BRACE_L,\n    parseFieldDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: INTERFACE_TYPE_DEFINITION,\n    name,\n    directives,\n    fields,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\nfunction parseUnionTypeDefinition(parser: Parser): UnionTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'union');\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  expect(parser, TokenKind.EQUALS);\n  const types = parseUnionMembers(parser);\n  return {\n    kind: UNION_TYPE_DEFINITION,\n    name,\n    directives,\n    types,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * UnionMembers :\n *   - NamedType\n *   - UnionMembers | NamedType\n */\nfunction parseUnionMembers(parser: Parser): Array<NamedType> {\n  const members = [];\n  do {\n    members.push(parseNamedType(parser));\n  } while (skip(parser, TokenKind.PIPE));\n  return members;\n}\n\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\nfunction parseEnumTypeDefinition(parser: Parser): EnumTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'enum');\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  const values = many(\n    parser,\n    TokenKind.BRACE_L,\n    parseEnumValueDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: ENUM_TYPE_DEFINITION,\n    name,\n    directives,\n    values,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(parser: Parser) : EnumValueDefinition {\n  const start = parser.token.start;\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  return {\n    kind: ENUM_VALUE_DEFINITION,\n    name,\n    directives,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\nfunction parseInputObjectTypeDefinition(\n  parser: Parser\n): InputObjectTypeDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'input');\n  const name = parseName(parser);\n  const directives = parseDirectives(parser);\n  const fields = any(\n    parser,\n    TokenKind.BRACE_L,\n    parseInputValueDef,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: INPUT_OBJECT_TYPE_DEFINITION,\n    name,\n    directives,\n    fields,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\nfunction parseTypeExtensionDefinition(parser: Parser): TypeExtensionDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'extend');\n  const definition = parseObjectTypeDefinition(parser);\n  return {\n    kind: TYPE_EXTENSION_DEFINITION,\n    definition,\n    loc: loc(parser, start),\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(parser: Parser): DirectiveDefinition {\n  const start = parser.token.start;\n  expectKeyword(parser, 'directive');\n  expect(parser, TokenKind.AT);\n  const name = parseName(parser);\n  const args = parseArgumentDefs(parser);\n  expectKeyword(parser, 'on');\n  const locations = parseDirectiveLocations(parser);\n  return {\n    kind: DIRECTIVE_DEFINITION,\n    name,\n    arguments: args,\n    locations,\n    loc: loc(parser, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - Name\n *   - DirectiveLocations | Name\n */\nfunction parseDirectiveLocations(parser: Parser): Array<Name> {\n  const locations = [];\n  do {\n    locations.push(parseName(parser));\n  } while (skip(parser, TokenKind.PIPE));\n  return locations;\n}\n\n// Core parsing utility functions\n\ntype Parser = {\n  source: Source,\n  options: ParseOptions,\n  prevEnd: number,\n  token: Token,\n  _lexToken: () => Token,\n};\n\n/**\n * Returns the parser object that is used to store state throughout the\n * process of parsing.\n */\nfunction makeParser(source: Source, options: ParseOptions): Parser {\n  const _lexToken = lex(source);\n  return {\n    _lexToken,\n    source,\n    options,\n    prevEnd: 0,\n    token: _lexToken(),\n  };\n}\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(parser: Parser, start: number) {\n  if (parser.options.noLocation) {\n    return null;\n  }\n  if (parser.options.noSource) {\n    return { start, end: parser.prevEnd };\n  }\n  return { start, end: parser.prevEnd, source: parser.source };\n}\n\n/**\n * Moves the internal parser object to the next lexed token.\n */\nfunction advance(parser: Parser): void {\n  const prevEnd = parser.token.end;\n  parser.prevEnd = prevEnd;\n  parser.token = parser._lexToken(prevEnd);\n}\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(parser: Parser, kind: number): boolean {\n  return parser.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the parser. Otherwise, do not change the parser state and return false.\n */\nfunction skip(parser: Parser, kind: number): boolean {\n  const match = parser.token.kind === kind;\n  if (match) {\n    advance(parser);\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the parser. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(parser: Parser, kind: number): Token {\n  const token = parser.token;\n  if (token.kind === kind) {\n    advance(parser);\n    return token;\n  }\n  throw syntaxError(\n    parser.source,\n    token.start,\n    `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the parser. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(parser: Parser, value: string): Token {\n  const token = parser.token;\n  if (token.kind === TokenKind.NAME && token.value === value) {\n    advance(parser);\n    return token;\n  }\n  throw syntaxError(\n    parser.source,\n    token.start,\n    `Expected \"${value}\", found ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(parser: Parser, atToken?: ?Token): Error {\n  const token = atToken || parser.token;\n  return syntaxError(\n    parser.source,\n    token.start,\n    `Unexpected ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any<T>(\n  parser: Parser,\n  openKind: number,\n  parseFn: (parser: Parser) => T,\n  closeKind: number\n): Array<T> {\n  expect(parser, openKind);\n  const nodes = [];\n  while (!skip(parser, closeKind)) {\n    nodes.push(parseFn(parser));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many<T>(\n  parser: Parser,\n  openKind: number,\n  parseFn: (parser: Parser) => T,\n  closeKind: number\n): Array<T> {\n  expect(parser, openKind);\n  const nodes = [ parseFn(parser) ];\n  while (!skip(parser, closeKind)) {\n    nodes.push(parseFn(parser));\n  }\n  return nodes;\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}