{"version":3,"sources":["language/parser.js"],"names":[],"mappings":"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","file":"language/parser.js","sourcesContent":["/* @flow */\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport { Source } from './source';\nimport { syntaxError } from '../error';\nimport type { GraphQLError } from '../error';\nimport {\n  createLexer,\n  TokenKind,\n  getTokenDesc\n} from './lexer';\nimport type { Lexer } from './lexer';\nimport type {\n  Location,\n  Token,\n\n  Name,\n  Variable,\n\n  Document,\n  Definition,\n  OperationDefinition,\n  OperationType,\n  VariableDefinition,\n  SelectionSet,\n  Selection,\n  Field,\n  Argument,\n\n  FragmentSpread,\n  InlineFragment,\n  FragmentDefinition,\n\n  Value,\n  ListValue,\n  ObjectValue,\n  ObjectField,\n\n  Directive,\n\n  Type,\n  NamedType,\n  ListType,\n  NonNullType,\n\n  TypeSystemDefinition,\n\n  SchemaDefinition,\n  OperationTypeDefinition,\n\n  ScalarTypeDefinition,\n  ObjectTypeDefinition,\n  FieldDefinition,\n  InputValueDefinition,\n  InterfaceTypeDefinition,\n  UnionTypeDefinition,\n  EnumTypeDefinition,\n  EnumValueDefinition,\n  InputObjectTypeDefinition,\n\n  TypeExtensionDefinition,\n\n  DirectiveDefinition,\n} from './ast';\n\nimport {\n  NAME,\n  VARIABLE,\n\n  DOCUMENT,\n  OPERATION_DEFINITION,\n  VARIABLE_DEFINITION,\n  SELECTION_SET,\n  FIELD,\n  ARGUMENT,\n\n  FRAGMENT_SPREAD,\n  INLINE_FRAGMENT,\n  FRAGMENT_DEFINITION,\n\n  INT,\n  FLOAT,\n  STRING,\n  BOOLEAN,\n  ENUM,\n  LIST,\n  OBJECT,\n  OBJECT_FIELD,\n\n  DIRECTIVE,\n\n  NAMED_TYPE,\n  LIST_TYPE,\n  NON_NULL_TYPE,\n\n  SCHEMA_DEFINITION,\n  OPERATION_TYPE_DEFINITION,\n\n  SCALAR_TYPE_DEFINITION,\n  OBJECT_TYPE_DEFINITION,\n  FIELD_DEFINITION,\n  INPUT_VALUE_DEFINITION,\n  INTERFACE_TYPE_DEFINITION,\n  UNION_TYPE_DEFINITION,\n  ENUM_TYPE_DEFINITION,\n  ENUM_VALUE_DEFINITION,\n  INPUT_OBJECT_TYPE_DEFINITION,\n\n  TYPE_EXTENSION_DEFINITION,\n\n  DIRECTIVE_DEFINITION,\n} from './kinds';\n\n\n/**\n * Configuration options to control parser behavior\n */\nexport type ParseOptions = {\n  /**\n   * By default, the parser creates AST nodes that know the location\n   * in the source that they correspond to. This configuration flag\n   * disables that behavior for performance or testing.\n   */\n  noLocation?: boolean\n};\n\n/**\n * Given a GraphQL source, parses it into a Document.\n * Throws GraphQLError if a syntax error is encountered.\n */\nexport function parse(\n  source: string | Source,\n  options?: ParseOptions\n): Document {\n  const sourceObj = typeof source === 'string' ? new Source(source) : source;\n  const lexer = createLexer(sourceObj, options || {});\n  return parseDocument(lexer);\n}\n\n/**\n * Given a string containing a GraphQL value, parse the AST for that value.\n * Throws GraphQLError if a syntax error is encountered.\n *\n * This is useful within tools that operate upon GraphQL Values directly and\n * in isolation of complete GraphQL documents.\n */\nexport function parseValue(\n  source: string | Source,\n  options?: ParseOptions\n): Value {\n  const sourceObj = typeof source === 'string' ? new Source(source) : source;\n  const lexer = createLexer(sourceObj, options || {});\n  expect(lexer, TokenKind.SOF);\n  const value = parseValueLiteral(lexer, false);\n  expect(lexer, TokenKind.EOF);\n  return value;\n}\n\n/**\n * Converts a name lex token into a name parse node.\n */\nfunction parseName(lexer: Lexer<*>): Name {\n  const token = expect(lexer, TokenKind.NAME);\n  return {\n    kind: NAME,\n    value: ((token.value: any): string),\n    loc: loc(lexer, token)\n  };\n}\n\n// Implements the parsing rules in the Document section.\n\n/**\n * Document : Definition+\n */\nfunction parseDocument(lexer: Lexer<*>): Document {\n  const start = lexer.token;\n  expect(lexer, TokenKind.SOF);\n  const definitions = [];\n  do {\n    definitions.push(parseDefinition(lexer));\n  } while (!skip(lexer, TokenKind.EOF));\n\n  return {\n    kind: DOCUMENT,\n    definitions,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Definition :\n *   - OperationDefinition\n *   - FragmentDefinition\n *   - TypeSystemDefinition\n */\nfunction parseDefinition(lexer: Lexer<*>): Definition {\n  if (peek(lexer, TokenKind.BRACE_L)) {\n    return parseOperationDefinition(lexer);\n  }\n\n  if (peek(lexer, TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      // Note: subscription is an experimental non-spec addition.\n      case 'query':\n      case 'mutation':\n      case 'subscription':\n        return parseOperationDefinition(lexer);\n\n      case 'fragment': return parseFragmentDefinition(lexer);\n\n      // Note: the Type System IDL is an experimental non-spec addition.\n      case 'schema':\n      case 'scalar':\n      case 'type':\n      case 'interface':\n      case 'union':\n      case 'enum':\n      case 'input':\n      case 'extend':\n      case 'directive': return parseTypeSystemDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n\n// Implements the parsing rules in the Operations section.\n\n/**\n * OperationDefinition :\n *  - SelectionSet\n *  - OperationType Name? VariableDefinitions? Directives? SelectionSet\n */\nfunction parseOperationDefinition(lexer: Lexer<*>): OperationDefinition {\n  const start = lexer.token;\n  if (peek(lexer, TokenKind.BRACE_L)) {\n    return {\n      kind: OPERATION_DEFINITION,\n      operation: 'query',\n      name: null,\n      variableDefinitions: null,\n      directives: [],\n      selectionSet: parseSelectionSet(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  const operation = parseOperationType(lexer);\n  let name;\n  if (peek(lexer, TokenKind.NAME)) {\n    name = parseName(lexer);\n  }\n  return {\n    kind: OPERATION_DEFINITION,\n    operation,\n    name,\n    variableDefinitions: parseVariableDefinitions(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * OperationType : one of query mutation subscription\n */\nfunction parseOperationType(lexer: Lexer<*>): OperationType {\n  const operationToken = expect(lexer, TokenKind.NAME);\n  switch (operationToken.value) {\n    case 'query': return 'query';\n    case 'mutation': return 'mutation';\n    // Note: subscription is an experimental non-spec addition.\n    case 'subscription': return 'subscription';\n  }\n\n  throw unexpected(lexer, operationToken);\n}\n\n/**\n * VariableDefinitions : ( VariableDefinition+ )\n */\nfunction parseVariableDefinitions(lexer: Lexer<*>): Array<VariableDefinition> {\n  return peek(lexer, TokenKind.PAREN_L) ?\n    many(\n      lexer,\n      TokenKind.PAREN_L,\n      parseVariableDefinition,\n      TokenKind.PAREN_R\n    ) :\n    [];\n}\n\n/**\n * VariableDefinition : Variable : Type DefaultValue?\n */\nfunction parseVariableDefinition(lexer: Lexer<*>): VariableDefinition {\n  const start = lexer.token;\n  return {\n    kind: VARIABLE_DEFINITION,\n    variable: parseVariable(lexer),\n    type: (expect(lexer, TokenKind.COLON), parseType(lexer)),\n    defaultValue:\n      skip(lexer, TokenKind.EQUALS) ? parseValueLiteral(lexer, true) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Variable : $ Name\n */\nfunction parseVariable(lexer: Lexer<*>): Variable {\n  const start = lexer.token;\n  expect(lexer, TokenKind.DOLLAR);\n  return {\n    kind: VARIABLE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * SelectionSet : { Selection+ }\n */\nfunction parseSelectionSet(lexer: Lexer<*>): SelectionSet {\n  const start = lexer.token;\n  return {\n    kind: SELECTION_SET,\n    selections:\n      many(lexer, TokenKind.BRACE_L, parseSelection, TokenKind.BRACE_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Selection :\n *   - Field\n *   - FragmentSpread\n *   - InlineFragment\n */\nfunction parseSelection(lexer: Lexer<*>): Selection {\n  return peek(lexer, TokenKind.SPREAD) ?\n    parseFragment(lexer) :\n    parseField(lexer);\n}\n\n/**\n * Field : Alias? Name Arguments? Directives? SelectionSet?\n *\n * Alias : Name :\n */\nfunction parseField(lexer: Lexer<*>): Field {\n  const start = lexer.token;\n\n  const nameOrAlias = parseName(lexer);\n  let alias;\n  let name;\n  if (skip(lexer, TokenKind.COLON)) {\n    alias = nameOrAlias;\n    name = parseName(lexer);\n  } else {\n    alias = null;\n    name = nameOrAlias;\n  }\n\n  return {\n    kind: FIELD,\n    alias,\n    name,\n    arguments: parseArguments(lexer),\n    directives: parseDirectives(lexer),\n    selectionSet:\n      peek(lexer, TokenKind.BRACE_L) ? parseSelectionSet(lexer) : null,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * Arguments : ( Argument+ )\n */\nfunction parseArguments(lexer: Lexer<*>): Array<Argument> {\n  return peek(lexer, TokenKind.PAREN_L) ?\n    many(lexer, TokenKind.PAREN_L, parseArgument, TokenKind.PAREN_R) :\n    [];\n}\n\n/**\n * Argument : Name : Value\n */\nfunction parseArgument(lexer: Lexer<*>): Argument {\n  const start = lexer.token;\n  return {\n    kind: ARGUMENT,\n    name: parseName(lexer),\n    value: (expect(lexer, TokenKind.COLON), parseValueLiteral(lexer, false)),\n    loc: loc(lexer, start)\n  };\n}\n\n\n// Implements the parsing rules in the Fragments section.\n\n/**\n * Corresponds to both FragmentSpread and InlineFragment in the spec.\n *\n * FragmentSpread : ... FragmentName Directives?\n *\n * InlineFragment : ... TypeCondition? Directives? SelectionSet\n */\nfunction parseFragment(lexer: Lexer<*>): FragmentSpread | InlineFragment {\n  const start = lexer.token;\n  expect(lexer, TokenKind.SPREAD);\n  if (peek(lexer, TokenKind.NAME) && lexer.token.value !== 'on') {\n    return {\n      kind: FRAGMENT_SPREAD,\n      name: parseFragmentName(lexer),\n      directives: parseDirectives(lexer),\n      loc: loc(lexer, start)\n    };\n  }\n  let typeCondition = null;\n  if (lexer.token.value === 'on') {\n    lexer.advance();\n    typeCondition = parseNamedType(lexer);\n  }\n  return {\n    kind: INLINE_FRAGMENT,\n    typeCondition,\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentDefinition :\n *   - fragment FragmentName on TypeCondition Directives? SelectionSet\n *\n * TypeCondition : NamedType\n */\nfunction parseFragmentDefinition(lexer: Lexer<*>): FragmentDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'fragment');\n  return {\n    kind: FRAGMENT_DEFINITION,\n    name: parseFragmentName(lexer),\n    typeCondition: (expectKeyword(lexer, 'on'), parseNamedType(lexer)),\n    directives: parseDirectives(lexer),\n    selectionSet: parseSelectionSet(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * FragmentName : Name but not `on`\n */\nfunction parseFragmentName(lexer: Lexer<*>): Name {\n  if (lexer.token.value === 'on') {\n    throw unexpected(lexer);\n  }\n  return parseName(lexer);\n}\n\n\n// Implements the parsing rules in the Values section.\n\n/**\n * Value[Const] :\n *   - [~Const] Variable\n *   - IntValue\n *   - FloatValue\n *   - StringValue\n *   - BooleanValue\n *   - EnumValue\n *   - ListValue[?Const]\n *   - ObjectValue[?Const]\n *\n * BooleanValue : one of `true` `false`\n *\n * EnumValue : Name but not `true`, `false` or `null`\n */\nfunction parseValueLiteral(lexer: Lexer<*>, isConst: boolean): Value {\n  const token = lexer.token;\n  switch (token.kind) {\n    case TokenKind.BRACKET_L:\n      return parseList(lexer, isConst);\n    case TokenKind.BRACE_L:\n      return parseObject(lexer, isConst);\n    case TokenKind.INT:\n      lexer.advance();\n      return {\n        kind: (INT: 'IntValue'),\n        value: ((token.value: any): string),\n        loc: loc(lexer, token)\n      };\n    case TokenKind.FLOAT:\n      lexer.advance();\n      return {\n        kind: (FLOAT: 'FloatValue'),\n        value: ((token.value: any): string),\n        loc: loc(lexer, token)\n      };\n    case TokenKind.STRING:\n      lexer.advance();\n      return {\n        kind: (STRING: 'StringValue'),\n        value: ((token.value: any): string),\n        loc: loc(lexer, token)\n      };\n    case TokenKind.NAME:\n      if (token.value === 'true' || token.value === 'false') {\n        lexer.advance();\n        return {\n          kind: (BOOLEAN: 'BooleanValue'),\n          value: token.value === 'true',\n          loc: loc(lexer, token)\n        };\n      } else if (token.value !== 'null') {\n        lexer.advance();\n        return {\n          kind: (ENUM: 'EnumValue'),\n          value: ((token.value: any): string),\n          loc: loc(lexer, token)\n        };\n      }\n      break;\n    case TokenKind.DOLLAR:\n      if (!isConst) {\n        return parseVariable(lexer);\n      }\n      break;\n  }\n  throw unexpected(lexer);\n}\n\nexport function parseConstValue(lexer: Lexer<*>): Value {\n  return parseValueLiteral(lexer, true);\n}\n\nfunction parseValueValue(lexer: Lexer<*>): Value {\n  return parseValueLiteral(lexer, false);\n}\n\n/**\n * ListValue[Const] :\n *   - [ ]\n *   - [ Value[?Const]+ ]\n */\nfunction parseList(lexer: Lexer<*>, isConst: boolean): ListValue {\n  const start = lexer.token;\n  const item = isConst ? parseConstValue : parseValueValue;\n  return {\n    kind: LIST,\n    values: any(lexer, TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectValue[Const] :\n *   - { }\n *   - { ObjectField[?Const]+ }\n */\nfunction parseObject(lexer: Lexer<*>, isConst: boolean): ObjectValue {\n  const start = lexer.token;\n  expect(lexer, TokenKind.BRACE_L);\n  const fields = [];\n  while (!skip(lexer, TokenKind.BRACE_R)) {\n    fields.push(parseObjectField(lexer, isConst));\n  }\n  return {\n    kind: OBJECT,\n    fields,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * ObjectField[Const] : Name : Value[?Const]\n */\nfunction parseObjectField(lexer: Lexer<*>, isConst: boolean): ObjectField {\n  const start = lexer.token;\n  return {\n    kind: OBJECT_FIELD,\n    name: parseName(lexer),\n    value:\n      (expect(lexer, TokenKind.COLON), parseValueLiteral(lexer, isConst)),\n    loc: loc(lexer, start)\n  };\n}\n\n\n// Implements the parsing rules in the Directives section.\n\n/**\n * Directives : Directive+\n */\nfunction parseDirectives(lexer: Lexer<*>): Array<Directive> {\n  const directives = [];\n  while (peek(lexer, TokenKind.AT)) {\n    directives.push(parseDirective(lexer));\n  }\n  return directives;\n}\n\n/**\n * Directive : @ Name Arguments?\n */\nfunction parseDirective(lexer: Lexer<*>): Directive {\n  const start = lexer.token;\n  expect(lexer, TokenKind.AT);\n  return {\n    kind: DIRECTIVE,\n    name: parseName(lexer),\n    arguments: parseArguments(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n\n// Implements the parsing rules in the Types section.\n\n/**\n * Type :\n *   - NamedType\n *   - ListType\n *   - NonNullType\n */\nexport function parseType(lexer: Lexer<*>): Type {\n  const start = lexer.token;\n  let type;\n  if (skip(lexer, TokenKind.BRACKET_L)) {\n    type = parseType(lexer);\n    expect(lexer, TokenKind.BRACKET_R);\n    type = ({\n      kind: LIST_TYPE,\n      type,\n      loc: loc(lexer, start)\n    }: ListType);\n  } else {\n    type = parseNamedType(lexer);\n  }\n  if (skip(lexer, TokenKind.BANG)) {\n    return ({\n      kind: NON_NULL_TYPE,\n      type,\n      loc: loc(lexer, start)\n    }: NonNullType);\n  }\n  return type;\n}\n\n/**\n * NamedType : Name\n */\nexport function parseNamedType(lexer: Lexer<*>): NamedType {\n  const start = lexer.token;\n  return {\n    kind: NAMED_TYPE,\n    name: parseName(lexer),\n    loc: loc(lexer, start)\n  };\n}\n\n\n// Implements the parsing rules in the Type Definition section.\n\n/**\n * TypeSystemDefinition :\n *   - SchemaDefinition\n *   - TypeDefinition\n *   - TypeExtensionDefinition\n *   - DirectiveDefinition\n *\n * TypeDefinition :\n *   - ScalarTypeDefinition\n *   - ObjectTypeDefinition\n *   - InterfaceTypeDefinition\n *   - UnionTypeDefinition\n *   - EnumTypeDefinition\n *   - InputObjectTypeDefinition\n */\nfunction parseTypeSystemDefinition(lexer: Lexer<*>): TypeSystemDefinition {\n  if (peek(lexer, TokenKind.NAME)) {\n    switch (lexer.token.value) {\n      case 'schema': return parseSchemaDefinition(lexer);\n      case 'scalar': return parseScalarTypeDefinition(lexer);\n      case 'type': return parseObjectTypeDefinition(lexer);\n      case 'interface': return parseInterfaceTypeDefinition(lexer);\n      case 'union': return parseUnionTypeDefinition(lexer);\n      case 'enum': return parseEnumTypeDefinition(lexer);\n      case 'input': return parseInputObjectTypeDefinition(lexer);\n      case 'extend': return parseTypeExtensionDefinition(lexer);\n      case 'directive': return parseDirectiveDefinition(lexer);\n    }\n  }\n\n  throw unexpected(lexer);\n}\n\n/**\n * SchemaDefinition : schema Directives? { OperationTypeDefinition+ }\n *\n * OperationTypeDefinition : OperationType : NamedType\n */\nfunction parseSchemaDefinition(lexer: Lexer<*>): SchemaDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'schema');\n  const directives = parseDirectives(lexer);\n  const operationTypes = many(\n    lexer,\n    TokenKind.BRACE_L,\n    parseOperationTypeDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: SCHEMA_DEFINITION,\n    directives,\n    operationTypes,\n    loc: loc(lexer, start),\n  };\n}\n\nfunction parseOperationTypeDefinition(\n  lexer: Lexer<*>\n): OperationTypeDefinition {\n  const start = lexer.token;\n  const operation = parseOperationType(lexer);\n  expect(lexer, TokenKind.COLON);\n  const type = parseNamedType(lexer);\n  return {\n    kind: OPERATION_TYPE_DEFINITION,\n    operation,\n    type,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * ScalarTypeDefinition : scalar Name Directives?\n */\nfunction parseScalarTypeDefinition(lexer: Lexer<*>): ScalarTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'scalar');\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  return {\n    kind: SCALAR_TYPE_DEFINITION,\n    name,\n    directives,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * ObjectTypeDefinition :\n *   - type Name ImplementsInterfaces? Directives? { FieldDefinition+ }\n */\nfunction parseObjectTypeDefinition(lexer: Lexer<*>): ObjectTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'type');\n  const name = parseName(lexer);\n  const interfaces = parseImplementsInterfaces(lexer);\n  const directives = parseDirectives(lexer);\n  const fields = any(\n    lexer,\n    TokenKind.BRACE_L,\n    parseFieldDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: OBJECT_TYPE_DEFINITION,\n    name,\n    interfaces,\n    directives,\n    fields,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * ImplementsInterfaces : implements NamedType+\n */\nfunction parseImplementsInterfaces(lexer: Lexer<*>): Array<NamedType> {\n  const types = [];\n  if (lexer.token.value === 'implements') {\n    lexer.advance();\n    do {\n      types.push(parseNamedType(lexer));\n    } while (peek(lexer, TokenKind.NAME));\n  }\n  return types;\n}\n\n/**\n * FieldDefinition : Name ArgumentsDefinition? : Type Directives?\n */\nfunction parseFieldDefinition(lexer: Lexer<*>): FieldDefinition {\n  const start = lexer.token;\n  const name = parseName(lexer);\n  const args = parseArgumentDefs(lexer);\n  expect(lexer, TokenKind.COLON);\n  const type = parseType(lexer);\n  const directives = parseDirectives(lexer);\n  return {\n    kind: FIELD_DEFINITION,\n    name,\n    arguments: args,\n    type,\n    directives,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * ArgumentsDefinition : ( InputValueDefinition+ )\n */\nfunction parseArgumentDefs(lexer: Lexer<*>): Array<InputValueDefinition> {\n  if (!peek(lexer, TokenKind.PAREN_L)) {\n    return [];\n  }\n  return many(lexer, TokenKind.PAREN_L, parseInputValueDef, TokenKind.PAREN_R);\n}\n\n/**\n * InputValueDefinition : Name : Type DefaultValue? Directives?\n */\nfunction parseInputValueDef(lexer: Lexer<*>): InputValueDefinition {\n  const start = lexer.token;\n  const name = parseName(lexer);\n  expect(lexer, TokenKind.COLON);\n  const type = parseType(lexer);\n  let defaultValue = null;\n  if (skip(lexer, TokenKind.EQUALS)) {\n    defaultValue = parseConstValue(lexer);\n  }\n  const directives = parseDirectives(lexer);\n  return {\n    kind: INPUT_VALUE_DEFINITION,\n    name,\n    type,\n    defaultValue,\n    directives,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * InterfaceTypeDefinition : interface Name Directives? { FieldDefinition+ }\n */\nfunction parseInterfaceTypeDefinition(\n  lexer: Lexer<*>\n): InterfaceTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'interface');\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  const fields = any(\n    lexer,\n    TokenKind.BRACE_L,\n    parseFieldDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: INTERFACE_TYPE_DEFINITION,\n    name,\n    directives,\n    fields,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * UnionTypeDefinition : union Name Directives? = UnionMembers\n */\nfunction parseUnionTypeDefinition(lexer: Lexer<*>): UnionTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'union');\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  expect(lexer, TokenKind.EQUALS);\n  const types = parseUnionMembers(lexer);\n  return {\n    kind: UNION_TYPE_DEFINITION,\n    name,\n    directives,\n    types,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * UnionMembers :\n *   - NamedType\n *   - UnionMembers | NamedType\n */\nfunction parseUnionMembers(lexer: Lexer<*>): Array<NamedType> {\n  const members = [];\n  do {\n    members.push(parseNamedType(lexer));\n  } while (skip(lexer, TokenKind.PIPE));\n  return members;\n}\n\n/**\n * EnumTypeDefinition : enum Name Directives? { EnumValueDefinition+ }\n */\nfunction parseEnumTypeDefinition(lexer: Lexer<*>): EnumTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'enum');\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  const values = many(\n    lexer,\n    TokenKind.BRACE_L,\n    parseEnumValueDefinition,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: ENUM_TYPE_DEFINITION,\n    name,\n    directives,\n    values,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * EnumValueDefinition : EnumValue Directives?\n *\n * EnumValue : Name\n */\nfunction parseEnumValueDefinition(lexer: Lexer<*>) : EnumValueDefinition {\n  const start = lexer.token;\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  return {\n    kind: ENUM_VALUE_DEFINITION,\n    name,\n    directives,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * InputObjectTypeDefinition : input Name Directives? { InputValueDefinition+ }\n */\nfunction parseInputObjectTypeDefinition(\n  lexer: Lexer<*>\n): InputObjectTypeDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'input');\n  const name = parseName(lexer);\n  const directives = parseDirectives(lexer);\n  const fields = any(\n    lexer,\n    TokenKind.BRACE_L,\n    parseInputValueDef,\n    TokenKind.BRACE_R\n  );\n  return {\n    kind: INPUT_OBJECT_TYPE_DEFINITION,\n    name,\n    directives,\n    fields,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * TypeExtensionDefinition : extend ObjectTypeDefinition\n */\nfunction parseTypeExtensionDefinition(\n  lexer: Lexer<*>\n): TypeExtensionDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'extend');\n  const definition = parseObjectTypeDefinition(lexer);\n  return {\n    kind: TYPE_EXTENSION_DEFINITION,\n    definition,\n    loc: loc(lexer, start),\n  };\n}\n\n/**\n * DirectiveDefinition :\n *   - directive @ Name ArgumentsDefinition? on DirectiveLocations\n */\nfunction parseDirectiveDefinition(lexer: Lexer<*>): DirectiveDefinition {\n  const start = lexer.token;\n  expectKeyword(lexer, 'directive');\n  expect(lexer, TokenKind.AT);\n  const name = parseName(lexer);\n  const args = parseArgumentDefs(lexer);\n  expectKeyword(lexer, 'on');\n  const locations = parseDirectiveLocations(lexer);\n  return {\n    kind: DIRECTIVE_DEFINITION,\n    name,\n    arguments: args,\n    locations,\n    loc: loc(lexer, start)\n  };\n}\n\n/**\n * DirectiveLocations :\n *   - Name\n *   - DirectiveLocations | Name\n */\nfunction parseDirectiveLocations(lexer: Lexer<*>): Array<Name> {\n  const locations = [];\n  do {\n    locations.push(parseName(lexer));\n  } while (skip(lexer, TokenKind.PIPE));\n  return locations;\n}\n\n// Core parsing utility functions\n\n/**\n * Returns a location object, used to identify the place in\n * the source that created a given parsed object.\n */\nfunction loc(lexer: Lexer<*>, startToken: Token): Location | void {\n  if (!lexer.options.noLocation) {\n    return new Loc(startToken, lexer.lastToken, lexer.source);\n  }\n}\n\nfunction Loc(startToken: Token, endToken: Token, source: Source) {\n  this.start = startToken.start;\n  this.end = endToken.end;\n  this.startToken = startToken;\n  this.endToken = endToken;\n  this.source = source;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nLoc.prototype.toJSON = Loc.prototype.inspect = function toJSON() {\n  return { start: this.start, end: this.end };\n};\n\n/**\n * Determines if the next token is of a given kind\n */\nfunction peek(lexer: Lexer<*>, kind: string): boolean {\n  return lexer.token.kind === kind;\n}\n\n/**\n * If the next token is of the given kind, return true after advancing\n * the lexer. Otherwise, do not change the parser state and return false.\n */\nfunction skip(lexer: Lexer<*>, kind: string): boolean {\n  const match = lexer.token.kind === kind;\n  if (match) {\n    lexer.advance();\n  }\n  return match;\n}\n\n/**\n * If the next token is of the given kind, return that token after advancing\n * the lexer. Otherwise, do not change the parser state and throw an error.\n */\nfunction expect(lexer: Lexer<*>, kind: string): Token {\n  const token = lexer.token;\n  if (token.kind === kind) {\n    lexer.advance();\n    return token;\n  }\n  throw syntaxError(\n    lexer.source,\n    token.start,\n    `Expected ${kind}, found ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * If the next token is a keyword with the given value, return that token after\n * advancing the lexer. Otherwise, do not change the parser state and return\n * false.\n */\nfunction expectKeyword(lexer: Lexer<*>, value: string): Token {\n  const token = lexer.token;\n  if (token.kind === TokenKind.NAME && token.value === value) {\n    lexer.advance();\n    return token;\n  }\n  throw syntaxError(\n    lexer.source,\n    token.start,\n    `Expected \"${value}\", found ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * Helper function for creating an error when an unexpected lexed token\n * is encountered.\n */\nfunction unexpected(lexer: Lexer<*>, atToken?: ?Token): GraphQLError {\n  const token = atToken || lexer.token;\n  return syntaxError(\n    lexer.source,\n    token.start,\n    `Unexpected ${getTokenDesc(token)}`\n  );\n}\n\n/**\n * Returns a possibly empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction any<T>(\n  lexer: Lexer<*>,\n  openKind: string,\n  parseFn: (lexer: Lexer<*>) => T,\n  closeKind: string\n): Array<T> {\n  expect(lexer, openKind);\n  const nodes = [];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n\n/**\n * Returns a non-empty list of parse nodes, determined by\n * the parseFn. This list begins with a lex token of openKind\n * and ends with a lex token of closeKind. Advances the parser\n * to the next lex token after the closing token.\n */\nfunction many<T>(\n  lexer: Lexer<*>,\n  openKind: string,\n  parseFn: (lexer: Lexer<*>) => T,\n  closeKind: string\n): Array<T> {\n  expect(lexer, openKind);\n  const nodes = [ parseFn(lexer) ];\n  while (!skip(lexer, closeKind)) {\n    nodes.push(parseFn(lexer));\n  }\n  return nodes;\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}