{"version":3,"sources":["language/lexer.js"],"names":[],"mappings":"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","file":"language/lexer.js","sourcesContent":["/* @flow /\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { Token } from './ast';\nimport type { Source } from './source';\nimport { syntaxError } from '../error';\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a stateful stream generator in that every time\n * it is advanced, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return the same EOF token\n * whenever called.\n */\nexport function createLexer<TOptions>(\n  source: Source,\n  options: TOptions\n): Lexer<TOptions> {\n  const startOfFileToken = new Tok(SOF, 0, 0, 0, 0, null);\n  const lexer: Lexer<TOptions> = {\n    source,\n    options,\n    lastToken: startOfFileToken,\n    token: startOfFileToken,\n    line: 1,\n    lineStart: 0,\n    advance: advanceLexer\n  };\n  return lexer;\n}\n\nfunction advanceLexer() {\n  let token = this.lastToken = this.token;\n  if (token.kind !== EOF) {\n    do {\n      token = token.next = readToken(this, token);\n    } while (token.kind === COMMENT);\n    this.token = token;\n  }\n  return token;\n}\n\n/**\n * The return type of createLexer.\n */\nexport type Lexer<TOptions> = {\n  source: Source;\n  options: TOptions;\n\n  /**\n   * The previously focused non-ignored token.\n   */\n  lastToken: Token;\n\n  /**\n   * The currently focused non-ignored token.\n   */\n  token: Token;\n\n  /**\n   * The (1-indexed) line containing the current token.\n   */\n  line: number;\n\n  /**\n   * The character offset at which the current line begins.\n   */\n  lineStart: number;\n\n  /**\n   * Advances the token stream to the next non-ignored token.\n   */\n  advance(): Token;\n};\n\n// Each kind of token.\nconst SOF = '<SOF>';\nconst EOF = '<EOF>';\nconst BANG = '!';\nconst DOLLAR = '$';\nconst PAREN_L = '(';\nconst PAREN_R = ')';\nconst SPREAD = '...';\nconst COLON = ':';\nconst EQUALS = '=';\nconst AT = '@';\nconst BRACKET_L = '[';\nconst BRACKET_R = ']';\nconst BRACE_L = '{';\nconst PIPE = '|';\nconst BRACE_R = '}';\nconst NAME = 'Name';\nconst INT = 'Int';\nconst FLOAT = 'Float';\nconst STRING = 'String';\nconst COMMENT = 'Comment';\n\n/**\n * An exported enum describing the different kinds of tokens that the\n * lexer emits.\n */\nexport const TokenKind = {\n  SOF,\n  EOF,\n  BANG,\n  DOLLAR,\n  PAREN_L,\n  PAREN_R,\n  SPREAD,\n  COLON,\n  EQUALS,\n  AT,\n  BRACKET_L,\n  BRACKET_R,\n  BRACE_L,\n  PIPE,\n  BRACE_R,\n  NAME,\n  INT,\n  FLOAT,\n  STRING,\n  COMMENT\n};\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nexport function getTokenDesc(token: Token): string {\n  const value = token.value;\n  return value ? `${token.kind} \"${value}\"` : token.kind;\n}\n\nconst charCodeAt = String.prototype.charCodeAt;\nconst slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction Tok(\n  kind,\n  start: number,\n  end: number,\n  line: number,\n  column: number,\n  prev: Token | null,\n  value?: string\n) {\n  this.kind = kind;\n  this.start = start;\n  this.end = end;\n  this.line = line;\n  this.column = column;\n  this.value = value;\n  this.prev = prev;\n  this.next = null;\n}\n\n// Print a simplified form when appearing in JSON/util.inspect.\nTok.prototype.toJSON = Tok.prototype.inspect = function toJSON() {\n  return {\n    kind: this.kind,\n    value: this.value,\n    line: this.line,\n    column: this.column\n  };\n};\n\nfunction printCharCode(code) {\n  return (\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? EOF :\n    // Trust JSON for ASCII.\n    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :\n    // Otherwise print the escaped form.\n    `\"\\\\u${('00' + code.toString(16).toUpperCase()).slice(-4)}\"`\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(lexer: Lexer<*>, prev: Token): Token {\n  const source = lexer.source;\n  const body = source.body;\n  const bodyLength = body.length;\n\n  const position = positionAfterWhitespace(body, prev.end, lexer);\n  const line = lexer.line;\n  const col = 1 + position - lexer.lineStart;\n\n  if (position >= bodyLength) {\n    return new Tok(EOF, bodyLength, bodyLength, line, col, prev);\n  }\n\n  const code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n    throw syntaxError(\n      source,\n      position,\n      `Invalid character ${printCharCode(code)}.`\n    );\n  }\n\n  switch (code) {\n    // !\n    case 33: return new Tok(BANG, position, position + 1, line, col, prev);\n    // #\n    case 35: return readComment(source, position, line, col, prev);\n    // $\n    case 36: return new Tok(DOLLAR, position, position + 1, line, col, prev);\n    // (\n    case 40: return new Tok(PAREN_L, position, position + 1, line, col, prev);\n    // )\n    case 41: return new Tok(PAREN_R, position, position + 1, line, col, prev);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 &&\n          charCodeAt.call(body, position + 2) === 46) {\n        return new Tok(SPREAD, position, position + 3, line, col, prev);\n      }\n      break;\n    // :\n    case 58: return new Tok(COLON, position, position + 1, line, col, prev);\n    // =\n    case 61: return new Tok(EQUALS, position, position + 1, line, col, prev);\n    // @\n    case 64: return new Tok(AT, position, position + 1, line, col, prev);\n    // [\n    case 91:\n      return new Tok(BRACKET_L, position, position + 1, line, col, prev);\n    // ]\n    case 93:\n      return new Tok(BRACKET_R, position, position + 1, line, col, prev);\n    // {\n    case 123:\n      return new Tok(BRACE_L, position, position + 1, line, col, prev);\n    // |\n    case 124: return new Tok(PIPE, position, position + 1, line, col, prev);\n    // }\n    case 125:\n      return new Tok(BRACE_R, position, position + 1, line, col, prev);\n    // A-Z _ a-z\n    case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72:\n    case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80:\n    case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88:\n    case 89: case 90:\n    case 95:\n    case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104:\n    case 105: case 106: case 107: case 108: case 109: case 110: case 111:\n    case 112: case 113: case 114: case 115: case 116: case 117: case 118:\n    case 119: case 120: case 121: case 122:\n      return readName(source, position, line, col, prev);\n    // - 0-9\n    case 45:\n    case 48: case 49: case 50: case 51: case 52:\n    case 53: case 54: case 55: case 56: case 57:\n      return readNumber(source, position, code, line, col, prev);\n    // \"\n    case 34: return readString(source, position, line, col, prev);\n  }\n\n  throw syntaxError(\n    source,\n    position,\n    `Unexpected character ${printCharCode(code)}.`\n  );\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(\n  body: string,\n  startPosition: number,\n  lexer: Lexer<*>\n): number {\n  const bodyLength = body.length;\n  let position = startPosition;\n  while (position < bodyLength) {\n    const code = charCodeAt.call(body, position);\n    // tab | space | comma | BOM\n    if (code === 9 || code === 32 || code === 44 || code === 0xFEFF) {\n      ++position;\n    } else if (code === 10) { // new line\n      ++position;\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else if (code === 13) { // carriage return\n      if (charCodeAt.call(body, position + 1) === 10) {\n        position += 2;\n      } else {\n        ++position;\n      }\n      ++lexer.line;\n      lexer.lineStart = position;\n    } else {\n      break;\n    }\n  }\n  return position;\n}\n\n/**\n * Reads a comment token from the source file.\n *\n * #[\\u0009\\u0020-\\uFFFF]*\n */\nfunction readComment(source, start, line, col, prev): Token {\n  const body = source.body;\n  let code;\n  let position = start;\n\n  do {\n    code = charCodeAt.call(body, ++position);\n  } while (\n    code !== null &&\n    // SourceCharacter but not LineTerminator\n    (code > 0x001F || code === 0x0009)\n  );\n\n  return new Tok(\n    COMMENT,\n    start,\n    position,\n    line,\n    col,\n    prev,\n    slice.call(body, start + 1, position)\n  );\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode, line, col, prev): Token {\n  const body = source.body;\n  let code = firstCode;\n  let position = start;\n  let isFloat = false;\n\n  if (code === 45) { // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) { // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(\n        source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCharCode(code)}.`\n      );\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) { // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) { // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) { // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return new Tok(\n    isFloat ? FLOAT : INT,\n    start,\n    position,\n    line,\n    col,\n    prev,\n    slice.call(body, start, position)\n  );\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  const body = source.body;\n  let position = start;\n  let code = firstCode;\n  if (code >= 48 && code <= 57) { // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw syntaxError(\n    source,\n    position,\n    `Invalid number, expected digit but got: ${printCharCode(code)}.`\n  );\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start, line, col, prev): Token {\n  const body = source.body;\n  let position = start + 1;\n  let chunkStart = position;\n  let code = 0;\n  let value = '';\n\n  while (\n    position < body.length &&\n    (code = charCodeAt.call(body, position)) !== null &&\n    // not LineTerminator\n    code !== 0x000A && code !== 0x000D &&\n    // not Quote (\")\n    code !== 34\n  ) {\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(\n        source,\n        position,\n        `Invalid character within String: ${printCharCode(code)}.`\n      );\n    }\n\n    ++position;\n    if (code === 92) { // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34: value += '\"'; break;\n        case 47: value += '\\/'; break;\n        case 92: value += '\\\\'; break;\n        case 98: value += '\\b'; break;\n        case 102: value += '\\f'; break;\n        case 110: value += '\\n'; break;\n        case 114: value += '\\r'; break;\n        case 116: value += '\\t'; break;\n        case 117: // u\n          const charCode = uniCharCode(\n            charCodeAt.call(body, position + 1),\n            charCodeAt.call(body, position + 2),\n            charCodeAt.call(body, position + 3),\n            charCodeAt.call(body, position + 4)\n          );\n          if (charCode < 0) {\n            throw syntaxError(\n              source,\n              position,\n              'Invalid character escape sequence: ' +\n              `\\\\u${body.slice(position + 1, position + 5)}.`\n            );\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw syntaxError(\n            source,\n            position,\n            `Invalid character escape sequence: \\\\${String.fromCharCode(code)}.`\n          );\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  if (code !== 34) { // quote (\")\n    throw syntaxError(source, position, 'Unterminated string.');\n  }\n\n  value += slice.call(body, chunkStart, position);\n  return new Tok(STRING, start, position + 1, line, col, prev, value);\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return (\n    a >= 48 && a <= 57 ? a - 48 : // 0-9\n    a >= 65 && a <= 70 ? a - 55 : // A-F\n    a >= 97 && a <= 102 ? a - 87 : // a-f\n    -1\n  );\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position, line, col, prev): Token {\n  const body = source.body;\n  const bodyLength = body.length;\n  let end = position + 1;\n  let code = 0;\n  while (\n    end !== bodyLength &&\n    (code = charCodeAt.call(body, end)) !== null &&\n    (\n      code === 95 || // _\n      code >= 48 && code <= 57 || // 0-9\n      code >= 65 && code <= 90 || // A-Z\n      code >= 97 && code <= 122 // a-z\n    )\n  ) {\n    ++end;\n  }\n  return new Tok(\n    NAME,\n    position,\n    end,\n    line,\n    col,\n    prev,\n    slice.call(body, position, end)\n  );\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}