{"version":3,"sources":["language/lexer.js"],"names":[],"mappings":";;;;;;QAqCgB;QAuCA;QAUA;;AA3EhB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BO,SAAS,GAAT,CAAa,MAAb,EAAoC;AACzC,MAAI,eAAe,CAAf,CADqC;AAEzC,SAAO,SAAS,SAAT,CAAmB,aAAnB,EAAkC;AACvC,QAAM,QAAQ,UACZ,MADY,EAEZ,kBAAkB,SAAlB,GAA8B,YAA9B,GAA6C,aAA7C,CAFI,CADiC;AAKvC,mBAAe,MAAM,GAAN,CALwB;AAMvC,WAAO,KAAP,CANuC;GAAlC,CAFkC;CAApC;;;;;AAeA,IAAM,gCAAY;AACvB,OAAK,CAAL;AACA,QAAM,CAAN;AACA,UAAQ,CAAR;AACA,WAAS,CAAT;AACA,WAAS,CAAT;AACA,UAAQ,CAAR;AACA,SAAO,CAAP;AACA,UAAQ,CAAR;AACA,MAAI,CAAJ;AACA,aAAW,EAAX;AACA,aAAW,EAAX;AACA,WAAS,EAAT;AACA,QAAM,EAAN;AACA,WAAS,EAAT;AACA,QAAM,EAAN;AACA,OAAK,EAAL;AACA,SAAO,EAAP;AACA,UAAQ,EAAR;CAlBW;;;;;AAwBN,SAAS,YAAT,CAAsB,KAAtB,EAA4C;AACjD,MAAM,QAAQ,MAAM,KAAN,CADmC;AAEjD,SAAO,QACF,iBAAiB,MAAM,IAAN,WAAgB,WAD/B,GAEL,iBAAiB,MAAM,IAAN,CAFZ,CAF0C;CAA5C;;;;;AAUA,SAAS,gBAAT,CAA0B,IAA1B,EAAgD;AACrD,SAAO,iBAAiB,IAAjB,CAAP,CADqD;CAAhD;;AAIP,IAAM,mBAAmB,EAAnB;AACN,iBAAiB,UAAU,GAAV,CAAjB,GAAkC,KAAlC;AACA,iBAAiB,UAAU,IAAV,CAAjB,GAAmC,GAAnC;AACA,iBAAiB,UAAU,MAAV,CAAjB,GAAqC,GAArC;AACA,iBAAiB,UAAU,OAAV,CAAjB,GAAsC,GAAtC;AACA,iBAAiB,UAAU,OAAV,CAAjB,GAAsC,GAAtC;AACA,iBAAiB,UAAU,MAAV,CAAjB,GAAqC,KAArC;AACA,iBAAiB,UAAU,KAAV,CAAjB,GAAoC,GAApC;AACA,iBAAiB,UAAU,MAAV,CAAjB,GAAqC,GAArC;AACA,iBAAiB,UAAU,EAAV,CAAjB,GAAiC,GAAjC;AACA,iBAAiB,UAAU,SAAV,CAAjB,GAAwC,GAAxC;AACA,iBAAiB,UAAU,SAAV,CAAjB,GAAwC,GAAxC;AACA,iBAAiB,UAAU,OAAV,CAAjB,GAAsC,GAAtC;AACA,iBAAiB,UAAU,IAAV,CAAjB,GAAmC,GAAnC;AACA,iBAAiB,UAAU,OAAV,CAAjB,GAAsC,GAAtC;AACA,iBAAiB,UAAU,IAAV,CAAjB,GAAmC,MAAnC;AACA,iBAAiB,UAAU,GAAV,CAAjB,GAAkC,KAAlC;AACA,iBAAiB,UAAU,KAAV,CAAjB,GAAoC,OAApC;AACA,iBAAiB,UAAU,MAAV,CAAjB,GAAqC,QAArC;;AAEA,IAAM,aAAa,OAAO,SAAP,CAAiB,UAAjB;AACnB,IAAM,QAAQ,OAAO,SAAP,CAAiB,KAAjB;;;;;AAKd,SAAS,SAAT,CACE,IADF,EAEE,KAFF,EAGE,GAHF,EAIE,KAJF,EAKS;AACP,SAAO,EAAE,UAAF,EAAQ,YAAR,EAAe,QAAf,EAAoB,YAApB,EAAP,CADO;CALT;;AASA,SAAS,aAAT,CAAuB,IAAvB,EAA6B;AAC3B;;AAEE,UAAM,IAAN,IAAc,OAAd;;AAEA,WAAO,MAAP,GAAgB,KAAK,SAAL,CAAe,OAAO,YAAP,CAAoB,IAApB,CAAf,CAAhB;;aAEO,CAAC,OAAO,KAAK,QAAL,CAAc,EAAd,EAAkB,WAAlB,EAAP,CAAD,CAAyC,KAAzC,CAA+C,CAAC,CAAD,OAFtD;IALyB;CAA7B;;;;;;;;;AAkBA,SAAS,SAAT,CAAmB,MAAnB,EAAmC,YAAnC,EAAgE;AAC9D,MAAM,OAAO,OAAO,IAAP,CADiD;AAE9D,MAAM,aAAa,KAAK,MAAL,CAF2C;;AAI9D,MAAM,WAAW,wBAAwB,IAAxB,EAA8B,YAA9B,CAAX,CAJwD;;AAM9D,MAAI,YAAY,UAAZ,EAAwB;AAC1B,WAAO,UAAU,UAAU,GAAV,EAAe,QAAzB,EAAmC,QAAnC,CAAP,CAD0B;GAA5B;;AAIA,MAAM,OAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP;;;AAVwD,MAa1D,OAAO,MAAP,IAAiB,SAAS,MAAT,IAAmB,SAAS,MAAT,IAAmB,SAAS,MAAT,EAAiB;AAC1E,UAAM,wBACJ,MADI,EAEJ,QAFI,yBAGiB,cAAc,IAAd,OAHjB,CAAN,CAD0E;GAA5E;;AAQA,UAAQ,IAAR;;AAEE,SAAK,EAAL;AAAS,aAAO,UAAU,UAAU,IAAV,EAAgB,QAA1B,EAAoC,WAAW,CAAX,CAA3C,CAAT;;AAFF,SAIO,EAAL;AAAS,aAAO,UAAU,UAAU,MAAV,EAAkB,QAA5B,EAAsC,WAAW,CAAX,CAA7C,CAAT;;AAJF,SAMO,EAAL;AAAS,aAAO,UAAU,UAAU,OAAV,EAAmB,QAA7B,EAAuC,WAAW,CAAX,CAA9C,CAAT;;AANF,SAQO,EAAL;AAAS,aAAO,UAAU,UAAU,OAAV,EAAmB,QAA7B,EAAuC,WAAW,CAAX,CAA9C,CAAT;;AARF,SAUO,EAAL;AACE,UAAI,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CAAtB,KAAwC,EAAxC,IACA,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CAAtB,KAAwC,EAAxC,EAA4C;AAC9C,eAAO,UAAU,UAAU,MAAV,EAAkB,QAA5B,EAAsC,WAAW,CAAX,CAA7C,CAD8C;OADhD;AAIA,YALF;;AAVF,SAiBO,EAAL;AAAS,aAAO,UAAU,UAAU,KAAV,EAAiB,QAA3B,EAAqC,WAAW,CAAX,CAA5C,CAAT;;AAjBF,SAmBO,EAAL;AAAS,aAAO,UAAU,UAAU,MAAV,EAAkB,QAA5B,EAAsC,WAAW,CAAX,CAA7C,CAAT;;AAnBF,SAqBO,EAAL;AAAS,aAAO,UAAU,UAAU,EAAV,EAAc,QAAxB,EAAkC,WAAW,CAAX,CAAzC,CAAT;;AArBF,SAuBO,EAAL;AAAS,aAAO,UAAU,UAAU,SAAV,EAAqB,QAA/B,EAAyC,WAAW,CAAX,CAAhD,CAAT;;AAvBF,SAyBO,EAAL;AAAS,aAAO,UAAU,UAAU,SAAV,EAAqB,QAA/B,EAAyC,WAAW,CAAX,CAAhD,CAAT;;AAzBF,SA2BO,GAAL;AAAU,aAAO,UAAU,UAAU,OAAV,EAAmB,QAA7B,EAAuC,WAAW,CAAX,CAA9C,CAAV;;AA3BF,SA6BO,GAAL;AAAU,aAAO,UAAU,UAAU,IAAV,EAAgB,QAA1B,EAAoC,WAAW,CAAX,CAA3C,CAAV;;AA7BF,SA+BO,GAAL;AAAU,aAAO,UAAU,UAAU,OAAV,EAAmB,QAA7B,EAAuC,WAAW,CAAX,CAA9C,CAAV;;AA/BF,SAiCO,EAAL,CAjCF,KAiCgB,EAAL,CAjCX,KAiCyB,EAAL,CAjCpB,KAiCkC,EAAL,CAjC7B,KAiC2C,EAAL,CAjCtC,KAiCoD,EAAL,CAjC/C,KAiC6D,EAAL,CAjCxD,KAiCsE,EAAL,CAjCjE;AAkCE,SAAK,EAAL,CAlCF,KAkCgB,EAAL,CAlCX,KAkCyB,EAAL,CAlCpB,KAkCkC,EAAL,CAlC7B,KAkC2C,EAAL,CAlCtC,KAkCoD,EAAL,CAlC/C,KAkC6D,EAAL,CAlCxD,KAkCsE,EAAL,CAlCjE;AAmCE,SAAK,EAAL,CAnCF,KAmCgB,EAAL,CAnCX,KAmCyB,EAAL,CAnCpB,KAmCkC,EAAL,CAnC7B,KAmC2C,EAAL,CAnCtC,KAmCoD,EAAL,CAnC/C,KAmC6D,EAAL,CAnCxD,KAmCsE,EAAL,CAnCjE;AAoCE,SAAK,EAAL,CApCF,KAoCgB,EAAL,CApCX;AAqCE,SAAK,EAAL,CArCF;AAsCE,SAAK,EAAL,CAtCF,KAsCgB,EAAL,CAtCX,KAsCyB,EAAL,CAtCpB,KAsCkC,GAAL,CAtC7B,KAsC4C,GAAL,CAtCvC,KAsCsD,GAAL,CAtCjD,KAsCgE,GAAL,CAtC3D,KAsC0E,GAAL,CAtCrE;AAuCE,SAAK,GAAL,CAvCF,KAuCiB,GAAL,CAvCZ,KAuC2B,GAAL,CAvCtB,KAuCqC,GAAL,CAvChC,KAuC+C,GAAL,CAvC1C,KAuCyD,GAAL,CAvCpD,KAuCmE,GAAL,CAvC9D;AAwCE,SAAK,GAAL,CAxCF,KAwCiB,GAAL,CAxCZ,KAwC2B,GAAL,CAxCtB,KAwCqC,GAAL,CAxChC,KAwC+C,GAAL,CAxC1C,KAwCyD,GAAL,CAxCpD,KAwCmE,GAAL,CAxC9D;AAyCE,SAAK,GAAL,CAzCF,KAyCiB,GAAL,CAzCZ,KAyC2B,GAAL,CAzCtB,KAyCqC,GAAL;AAC5B,aAAO,SAAS,MAAT,EAAiB,QAAjB,CAAP,CAD4B;;AAzChC,SA4CO,EAAL,CA5CF;AA6CE,SAAK,EAAL,CA7CF,KA6CgB,EAAL,CA7CX,KA6CyB,EAAL,CA7CpB,KA6CkC,EAAL,CA7C7B,KA6C2C,EAAL,CA7CtC;AA8CE,SAAK,EAAL,CA9CF,KA8CgB,EAAL,CA9CX,KA8CyB,EAAL,CA9CpB,KA8CkC,EAAL,CA9C7B,KA8C2C,EAAL;AAClC,aAAO,WAAW,MAAX,EAAmB,QAAnB,EAA6B,IAA7B,CAAP,CADkC;;AA9CtC,SAiDO,EAAL;AAAS,aAAO,WAAW,MAAX,EAAmB,QAAnB,CAAP,CAAT;AAjDF,GArB8D;;AAyE9D,QAAM,wBACJ,MADI,EAEJ,QAFI,4BAGoB,cAAc,IAAd,OAHpB,CAAN,CAzE8D;CAAhE;;;;;;;AAqFA,SAAS,uBAAT,CAAiC,IAAjC,EAA+C,aAA/C,EAA8E;AAC5E,MAAM,aAAa,KAAK,MAAL,CADyD;AAE5E,MAAI,WAAW,aAAX,CAFwE;AAG5E,SAAO,WAAW,UAAX,EAAuB;AAC5B,QAAI,OAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP;;AADwB;;AAK1B,aAAS,MAAT;;AAEA,aAAS,MAAT;AACA,aAAS,MAAT;;AAEA,aAAS,MAAT;AACA,aAAS,MAAT;;AAEA,aAAS,MAAT,EACA;AACA,QAAE,QAAF;;AADA,KAXF,MAcO,IAAI,SAAS,EAAT,EAAa;;AACtB,UAAE,QAAF,CADsB;AAEtB,eACE,WAAW,UAAX,IACA,CAAC,OAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP,CAAD,KAA6C,IAA7C;;AAEC,eAAO,MAAP,IAAiB,SAAS,MAAT,CAHlB,IAGsC,SAAS,MAAT,IAAmB,SAAS,MAAT,EACzD;AACA,YAAE,QAAF,CADA;SALF;OAFK,MAUA;AACL,cADK;OAVA;GAjBT;AA+BA,SAAO,QAAP,CAlC4E;CAA9E;;;;;;;;;AA4CA,SAAS,UAAT,CAAoB,MAApB,EAA4B,KAA5B,EAAmC,SAAnC,EAA8C;AAC5C,MAAM,OAAO,OAAO,IAAP,CAD+B;AAE5C,MAAI,OAAO,SAAP,CAFwC;AAG5C,MAAI,WAAW,KAAX,CAHwC;AAI5C,MAAI,UAAU,KAAV,CAJwC;;AAM5C,MAAI,SAAS,EAAT,EAAa;;AACf,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CADe;GAAjB;;AAIA,MAAI,SAAS,EAAT,EAAa;;AACf,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CADe;AAEf,QAAI,QAAQ,EAAR,IAAc,QAAQ,EAAR,EAAY;AAC5B,YAAM,wBACJ,MADI,EAEJ,QAFI,iDAGyC,cAAc,IAAd,OAHzC,CAAN,CAD4B;KAA9B;GAFF,MASO;AACL,eAAW,WAAW,MAAX,EAAmB,QAAnB,EAA6B,IAA7B,CAAX,CADK;AAEL,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP,CAFK;GATP;;AAcA,MAAI,SAAS,EAAT,EAAa;;AACf,cAAU,IAAV,CADe;;AAGf,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CAHe;AAIf,eAAW,WAAW,MAAX,EAAmB,QAAnB,EAA6B,IAA7B,CAAX,CAJe;AAKf,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP,CALe;GAAjB;;AAQA,MAAI,SAAS,EAAT,IAAe,SAAS,GAAT,EAAc;;AAC/B,cAAU,IAAV,CAD+B;;AAG/B,WAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CAH+B;AAI/B,QAAI,SAAS,EAAT,IAAe,SAAS,EAAT,EAAa;;AAC9B,aAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CAD8B;KAAhC;AAGA,eAAW,WAAW,MAAX,EAAmB,QAAnB,EAA6B,IAA7B,CAAX,CAP+B;GAAjC;;AAUA,SAAO,UACL,UAAU,UAAU,KAAV,GAAkB,UAAU,GAAV,EAC5B,KAFK,EAGL,QAHK,EAIL,MAAM,IAAN,CAAW,IAAX,EAAiB,KAAjB,EAAwB,QAAxB,CAJK,CAAP,CA1C4C;CAA9C;;;;;AAqDA,SAAS,UAAT,CAAoB,MAApB,EAA4B,KAA5B,EAAmC,SAAnC,EAA8C;AAC5C,MAAM,OAAO,OAAO,IAAP,CAD+B;AAE5C,MAAI,WAAW,KAAX,CAFwC;AAG5C,MAAI,OAAO,SAAP,CAHwC;AAI5C,MAAI,QAAQ,EAAR,IAAc,QAAQ,EAAR,EAAY;;AAC5B,OAAG;AACD,aAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,EAAE,QAAF,CAA7B,CADC;KAAH,QAES,QAAQ,EAAR,IAAc,QAAQ,EAAR;AAHK,WAIrB,QAAP,CAJ4B;GAA9B;AAMA,QAAM,wBACJ,MADI,EAEJ,QAFI,+CAGuC,cAAc,IAAd,OAHvC,CAAN,CAV4C;CAA9C;;;;;;;AAsBA,SAAS,UAAT,CAAoB,MAApB,EAA4B,KAA5B,EAAmC;AACjC,MAAM,OAAO,OAAO,IAAP,CADoB;AAEjC,MAAI,WAAW,QAAQ,CAAR,CAFkB;AAGjC,MAAI,aAAa,QAAb,CAH6B;AAIjC,MAAI,OAAO,CAAP,CAJ6B;AAKjC,MAAI,QAAQ,EAAR,CAL6B;;AAOjC,SACE,WAAW,KAAK,MAAL,IACX,CAAC,OAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP,CAAD,KAA6C,IAA7C;;AAEA,WAAS,MAAT,IAAmB,SAAS,MAAT;;AAEnB,WAAS,EAAT,EACA;;AAEA,QAAI,OAAO,MAAP,IAAiB,SAAS,MAAT,EAAiB;AACpC,YAAM,wBACJ,MADI,EAEJ,QAFI,wCAGgC,cAAc,IAAd,OAHhC,CAAN,CADoC;KAAtC;;AAQA,MAAE,QAAF,CAVA;AAWA,QAAI,SAAS,EAAT,EAAa;;AACf,eAAS,MAAM,IAAN,CAAW,IAAX,EAAiB,UAAjB,EAA6B,WAAW,CAAX,CAAtC,CADe;AAEf,aAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,QAAtB,CAAP,CAFe;AAGf,cAAQ,IAAR;AACE,aAAK,EAAL;AAAS,mBAAS,GAAT,CAAT;AADF,aAEO,EAAL;AAAS,mBAAS,IAAT,CAAT;AAFF,aAGO,EAAL;AAAS,mBAAS,IAAT,CAAT;AAHF,aAIO,EAAL;AAAS,mBAAS,IAAT,CAAT;AAJF,aAKO,GAAL;AAAU,mBAAS,IAAT,CAAV;AALF,aAMO,GAAL;AAAU,mBAAS,IAAT,CAAV;AANF,aAOO,GAAL;AAAU,mBAAS,IAAT,CAAV;AAPF,aAQO,GAAL;AAAU,mBAAS,IAAT,CAAV;AARF,aASO,GAAL;;AACE,cAAM,WAAW,YACf,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CADP,EAEf,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CAFP,EAGf,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CAHP,EAIf,WAAW,IAAX,CAAgB,IAAhB,EAAsB,WAAW,CAAX,CAJP,CAAX,CADR;AAOE,cAAI,WAAW,CAAX,EAAc;AAChB,kBAAM,wBACJ,MADI,EAEJ,QAFI,EAGJ,iDACM,KAAK,KAAL,CAAW,WAAW,CAAX,EAAc,WAAW,CAAX,QAD/B,CAHF,CADgB;WAAlB;AAQA,mBAAS,OAAO,YAAP,CAAoB,QAApB,CAAT,CAfF;AAgBE,sBAAY,CAAZ,CAhBF;AAiBE,gBAjBF;AATF;AA4BI,gBAAM,wBACJ,MADI,EAEJ,QAFI,4CAGoC,OAAO,YAAP,CAAoB,IAApB,OAHpC,CAAN,CADF;AA3BF,OAHe;AAqCf,QAAE,QAAF,CArCe;AAsCf,mBAAa,QAAb,CAtCe;KAAjB;GAlBF;;AA4DA,MAAI,SAAS,EAAT,EAAa;;AACf,UAAM,wBAAY,MAAZ,EAAoB,QAApB,EAA8B,sBAA9B,CAAN,CADe;GAAjB;;AAIA,WAAS,MAAM,IAAN,CAAW,IAAX,EAAiB,UAAjB,EAA6B,QAA7B,CAAT,CAvEiC;AAwEjC,SAAO,UAAU,UAAU,MAAV,EAAkB,KAA5B,EAAmC,WAAW,CAAX,EAAc,KAAjD,CAAP,CAxEiC;CAAnC;;;;;;;;;;;;AAqFA,SAAS,WAAT,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B,EAAiC;AAC/B,SAAO,SAAS,CAAT,KAAe,EAAf,GAAoB,SAAS,CAAT,KAAe,CAAf,GAAmB,SAAS,CAAT,KAAe,CAAf,GAAmB,SAAS,CAAT,CAA1D,CADwB;CAAjC;;;;;;;;;;AAYA,SAAS,QAAT,CAAkB,CAAlB,EAAqB;AACnB,SACE,KAAK,EAAL,IAAW,KAAK,EAAL,GAAU,IAAI,EAAJ;AACrB,OAAK,EAAL,IAAW,KAAK,EAAL,GAAU,IAAI,EAAJ;AACrB,OAAK,EAAL,IAAW,KAAK,GAAL,GAAW,IAAI,EAAJ;AACtB,GAAC,CAAD,CALiB;CAArB;;;;;;;AAcA,SAAS,QAAT,CAAkB,MAAlB,EAA0B,QAA1B,EAAoC;AAClC,MAAM,OAAO,OAAO,IAAP,CADqB;AAElC,MAAM,aAAa,KAAK,MAAL,CAFe;AAGlC,MAAI,MAAM,WAAW,CAAX,CAHwB;AAIlC,MAAI,OAAO,CAAP,CAJ8B;AAKlC,SACE,QAAQ,UAAR,IACA,CAAC,OAAO,WAAW,IAAX,CAAgB,IAAhB,EAAsB,GAAtB,CAAP,CAAD,KAAwC,IAAxC,KAEE,SAAS,EAAT;AACA,UAAQ,EAAR,IAAc,QAAQ,EAAR;AACd,UAAQ,EAAR,IAAc,QAAQ,EAAR;AACd,UAAQ,EAAR,IAAc,QAAQ,GAAR;GANhB,EAQA;AACA,MAAE,GAAF,CADA;GATF;AAYA,SAAO,UACL,UAAU,IAAV,EACA,QAFK,EAGL,GAHK,EAIL,MAAM,IAAN,CAAW,IAAX,EAAiB,QAAjB,EAA2B,GAA3B,CAJK,CAAP,CAjBkC;CAApC","file":"language/lexer.js","sourcesContent":["/* @flow /\n/**\n *  Copyright (c) 2015, Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree. An additional grant\n *  of patent rights can be found in the PATENTS file in the same directory.\n */\n\nimport type { Source } from './source';\nimport { syntaxError } from '../error';\n\n/**\n * A representation of a lexed Token. Value only appears for non-punctuation\n * tokens: NAME, INT, FLOAT, and STRING.\n */\nexport type Token = {\n  kind: number;\n  start: number;\n  end: number;\n  value: ?string;\n};\n\ntype Lexer = (resetPosition?: number) => Token;\n\n/**\n * Given a Source object, this returns a Lexer for that source.\n * A Lexer is a function that acts like a generator in that every time\n * it is called, it returns the next token in the Source. Assuming the\n * source lexes, the final Token emitted by the lexer will be of kind\n * EOF, after which the lexer will repeatedly return EOF tokens whenever\n * called.\n *\n * The argument to the lexer function is optional, and can be used to\n * rewind or fast forward the lexer to a new position in the source.\n */\nexport function lex(source: Source): Lexer {\n  let prevPosition = 0;\n  return function nextToken(resetPosition) {\n    const token = readToken(\n      source,\n      resetPosition === undefined ? prevPosition : resetPosition\n    );\n    prevPosition = token.end;\n    return token;\n  };\n}\n\n/**\n * An enum describing the different kinds of tokens that the lexer emits.\n */\nexport const TokenKind = {\n  EOF: 1,\n  BANG: 2,\n  DOLLAR: 3,\n  PAREN_L: 4,\n  PAREN_R: 5,\n  SPREAD: 6,\n  COLON: 7,\n  EQUALS: 8,\n  AT: 9,\n  BRACKET_L: 10,\n  BRACKET_R: 11,\n  BRACE_L: 12,\n  PIPE: 13,\n  BRACE_R: 14,\n  NAME: 15,\n  INT: 16,\n  FLOAT: 17,\n  STRING: 18,\n};\n\n/**\n * A helper function to describe a token as a string for debugging\n */\nexport function getTokenDesc(token: Token): string {\n  const value = token.value;\n  return value ?\n    `${getTokenKindDesc(token.kind)} \"${value}\"` :\n    getTokenKindDesc(token.kind);\n}\n\n/**\n * A helper function to describe a token kind as a string for debugging\n */\nexport function getTokenKindDesc(kind: number): string {\n  return tokenDescription[kind];\n}\n\nconst tokenDescription = {};\ntokenDescription[TokenKind.EOF] = 'EOF';\ntokenDescription[TokenKind.BANG] = '!';\ntokenDescription[TokenKind.DOLLAR] = '$';\ntokenDescription[TokenKind.PAREN_L] = '(';\ntokenDescription[TokenKind.PAREN_R] = ')';\ntokenDescription[TokenKind.SPREAD] = '...';\ntokenDescription[TokenKind.COLON] = ':';\ntokenDescription[TokenKind.EQUALS] = '=';\ntokenDescription[TokenKind.AT] = '@';\ntokenDescription[TokenKind.BRACKET_L] = '[';\ntokenDescription[TokenKind.BRACKET_R] = ']';\ntokenDescription[TokenKind.BRACE_L] = '{';\ntokenDescription[TokenKind.PIPE] = '|';\ntokenDescription[TokenKind.BRACE_R] = '}';\ntokenDescription[TokenKind.NAME] = 'Name';\ntokenDescription[TokenKind.INT] = 'Int';\ntokenDescription[TokenKind.FLOAT] = 'Float';\ntokenDescription[TokenKind.STRING] = 'String';\n\nconst charCodeAt = String.prototype.charCodeAt;\nconst slice = String.prototype.slice;\n\n/**\n * Helper function for constructing the Token object.\n */\nfunction makeToken(\n  kind: number,\n  start: number,\n  end: number,\n  value?: string\n): Token {\n  return { kind, start, end, value };\n}\n\nfunction printCharCode(code) {\n  return (\n    // NaN/undefined represents access beyond the end of the file.\n    isNaN(code) ? '<EOF>' :\n    // Trust JSON for ASCII.\n    code < 0x007F ? JSON.stringify(String.fromCharCode(code)) :\n    // Otherwise print the escaped form.\n    `\"\\\\u${('00' + code.toString(16).toUpperCase()).slice(-4)}\"`\n  );\n}\n\n/**\n * Gets the next token from the source starting at the given position.\n *\n * This skips over whitespace and comments until it finds the next lexable\n * token, then lexes punctuators immediately or calls the appropriate helper\n * function for more complicated tokens.\n */\nfunction readToken(source: Source, fromPosition: number): Token {\n  const body = source.body;\n  const bodyLength = body.length;\n\n  const position = positionAfterWhitespace(body, fromPosition);\n\n  if (position >= bodyLength) {\n    return makeToken(TokenKind.EOF, position, position);\n  }\n\n  const code = charCodeAt.call(body, position);\n\n  // SourceCharacter\n  if (code < 0x0020 && code !== 0x0009 && code !== 0x000A && code !== 0x000D) {\n    throw syntaxError(\n      source,\n      position,\n      `Invalid character ${printCharCode(code)}.`\n    );\n  }\n\n  switch (code) {\n    // !\n    case 33: return makeToken(TokenKind.BANG, position, position + 1);\n    // $\n    case 36: return makeToken(TokenKind.DOLLAR, position, position + 1);\n    // (\n    case 40: return makeToken(TokenKind.PAREN_L, position, position + 1);\n    // )\n    case 41: return makeToken(TokenKind.PAREN_R, position, position + 1);\n    // .\n    case 46:\n      if (charCodeAt.call(body, position + 1) === 46 &&\n          charCodeAt.call(body, position + 2) === 46) {\n        return makeToken(TokenKind.SPREAD, position, position + 3);\n      }\n      break;\n    // :\n    case 58: return makeToken(TokenKind.COLON, position, position + 1);\n    // =\n    case 61: return makeToken(TokenKind.EQUALS, position, position + 1);\n    // @\n    case 64: return makeToken(TokenKind.AT, position, position + 1);\n    // [\n    case 91: return makeToken(TokenKind.BRACKET_L, position, position + 1);\n    // ]\n    case 93: return makeToken(TokenKind.BRACKET_R, position, position + 1);\n    // {\n    case 123: return makeToken(TokenKind.BRACE_L, position, position + 1);\n    // |\n    case 124: return makeToken(TokenKind.PIPE, position, position + 1);\n    // }\n    case 125: return makeToken(TokenKind.BRACE_R, position, position + 1);\n    // A-Z _ a-z\n    case 65: case 66: case 67: case 68: case 69: case 70: case 71: case 72:\n    case 73: case 74: case 75: case 76: case 77: case 78: case 79: case 80:\n    case 81: case 82: case 83: case 84: case 85: case 86: case 87: case 88:\n    case 89: case 90:\n    case 95:\n    case 97: case 98: case 99: case 100: case 101: case 102: case 103: case 104:\n    case 105: case 106: case 107: case 108: case 109: case 110: case 111:\n    case 112: case 113: case 114: case 115: case 116: case 117: case 118:\n    case 119: case 120: case 121: case 122:\n      return readName(source, position);\n    // - 0-9\n    case 45:\n    case 48: case 49: case 50: case 51: case 52:\n    case 53: case 54: case 55: case 56: case 57:\n      return readNumber(source, position, code);\n    // \"\n    case 34: return readString(source, position);\n  }\n\n  throw syntaxError(\n    source,\n    position,\n    `Unexpected character ${printCharCode(code)}.`\n  );\n}\n\n/**\n * Reads from body starting at startPosition until it finds a non-whitespace\n * or commented character, then returns the position of that character for\n * lexing.\n */\nfunction positionAfterWhitespace(body: string, startPosition: number): number {\n  const bodyLength = body.length;\n  let position = startPosition;\n  while (position < bodyLength) {\n    let code = charCodeAt.call(body, position);\n    // Skip Ignored\n    if (\n      // BOM\n      code === 0xFEFF ||\n      // White Space\n      code === 0x0009 || // tab\n      code === 0x0020 || // space\n      // Line Terminator\n      code === 0x000A || // new line\n      code === 0x000D || // carriage return\n      // Comma\n      code === 0x002C\n    ) {\n      ++position;\n    // Skip comments\n    } else if (code === 35) { // #\n      ++position;\n      while (\n        position < bodyLength &&\n        (code = charCodeAt.call(body, position)) !== null &&\n        // SourceCharacter but not LineTerminator\n        (code > 0x001F || code === 0x0009) && code !== 0x000A && code !== 0x000D\n      ) {\n        ++position;\n      }\n    } else {\n      break;\n    }\n  }\n  return position;\n}\n\n/**\n * Reads a number token from the source file, either a float\n * or an int depending on whether a decimal point appears.\n *\n * Int:   -?(0|[1-9][0-9]*)\n * Float: -?(0|[1-9][0-9]*)(\\.[0-9]+)?((E|e)(+|-)?[0-9]+)?\n */\nfunction readNumber(source, start, firstCode) {\n  const body = source.body;\n  let code = firstCode;\n  let position = start;\n  let isFloat = false;\n\n  if (code === 45) { // -\n    code = charCodeAt.call(body, ++position);\n  }\n\n  if (code === 48) { // 0\n    code = charCodeAt.call(body, ++position);\n    if (code >= 48 && code <= 57) {\n      throw syntaxError(\n        source,\n        position,\n        `Invalid number, unexpected digit after 0: ${printCharCode(code)}.`\n      );\n    }\n  } else {\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 46) { // .\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    position = readDigits(source, position, code);\n    code = charCodeAt.call(body, position);\n  }\n\n  if (code === 69 || code === 101) { // E e\n    isFloat = true;\n\n    code = charCodeAt.call(body, ++position);\n    if (code === 43 || code === 45) { // + -\n      code = charCodeAt.call(body, ++position);\n    }\n    position = readDigits(source, position, code);\n  }\n\n  return makeToken(\n    isFloat ? TokenKind.FLOAT : TokenKind.INT,\n    start,\n    position,\n    slice.call(body, start, position)\n  );\n}\n\n/**\n * Returns the new position in the source after reading digits.\n */\nfunction readDigits(source, start, firstCode) {\n  const body = source.body;\n  let position = start;\n  let code = firstCode;\n  if (code >= 48 && code <= 57) { // 0 - 9\n    do {\n      code = charCodeAt.call(body, ++position);\n    } while (code >= 48 && code <= 57); // 0 - 9\n    return position;\n  }\n  throw syntaxError(\n    source,\n    position,\n    `Invalid number, expected digit but got: ${printCharCode(code)}.`\n  );\n}\n\n/**\n * Reads a string token from the source file.\n *\n * \"([^\"\\\\\\u000A\\u000D]|(\\\\(u[0-9a-fA-F]{4}|[\"\\\\/bfnrt])))*\"\n */\nfunction readString(source, start) {\n  const body = source.body;\n  let position = start + 1;\n  let chunkStart = position;\n  let code = 0;\n  let value = '';\n\n  while (\n    position < body.length &&\n    (code = charCodeAt.call(body, position)) !== null &&\n    // not LineTerminator\n    code !== 0x000A && code !== 0x000D &&\n    // not Quote (\")\n    code !== 34\n  ) {\n    // SourceCharacter\n    if (code < 0x0020 && code !== 0x0009) {\n      throw syntaxError(\n        source,\n        position,\n        `Invalid character within String: ${printCharCode(code)}.`\n      );\n    }\n\n    ++position;\n    if (code === 92) { // \\\n      value += slice.call(body, chunkStart, position - 1);\n      code = charCodeAt.call(body, position);\n      switch (code) {\n        case 34: value += '\"'; break;\n        case 47: value += '\\/'; break;\n        case 92: value += '\\\\'; break;\n        case 98: value += '\\b'; break;\n        case 102: value += '\\f'; break;\n        case 110: value += '\\n'; break;\n        case 114: value += '\\r'; break;\n        case 116: value += '\\t'; break;\n        case 117: // u\n          const charCode = uniCharCode(\n            charCodeAt.call(body, position + 1),\n            charCodeAt.call(body, position + 2),\n            charCodeAt.call(body, position + 3),\n            charCodeAt.call(body, position + 4)\n          );\n          if (charCode < 0) {\n            throw syntaxError(\n              source,\n              position,\n              'Invalid character escape sequence: ' +\n              `\\\\u${body.slice(position + 1, position + 5)}.`\n            );\n          }\n          value += String.fromCharCode(charCode);\n          position += 4;\n          break;\n        default:\n          throw syntaxError(\n            source,\n            position,\n            `Invalid character escape sequence: \\\\${String.fromCharCode(code)}.`\n          );\n      }\n      ++position;\n      chunkStart = position;\n    }\n  }\n\n  if (code !== 34) { // quote (\")\n    throw syntaxError(source, position, 'Unterminated string.');\n  }\n\n  value += slice.call(body, chunkStart, position);\n  return makeToken(TokenKind.STRING, start, position + 1, value);\n}\n\n/**\n * Converts four hexidecimal chars to the integer that the\n * string represents. For example, uniCharCode('0','0','0','f')\n * will return 15, and uniCharCode('0','0','f','f') returns 255.\n *\n * Returns a negative number on error, if a char was invalid.\n *\n * This is implemented by noting that char2hex() returns -1 on error,\n * which means the result of ORing the char2hex() will also be negative.\n */\nfunction uniCharCode(a, b, c, d) {\n  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);\n}\n\n/**\n * Converts a hex character to its integer value.\n * '0' becomes 0, '9' becomes 9\n * 'A' becomes 10, 'F' becomes 15\n * 'a' becomes 10, 'f' becomes 15\n *\n * Returns -1 on error.\n */\nfunction char2hex(a) {\n  return (\n    a >= 48 && a <= 57 ? a - 48 : // 0-9\n    a >= 65 && a <= 70 ? a - 55 : // A-F\n    a >= 97 && a <= 102 ? a - 87 : // a-f\n    -1\n  );\n}\n\n/**\n * Reads an alphanumeric + underscore name from the source.\n *\n * [_A-Za-z][_0-9A-Za-z]*\n */\nfunction readName(source, position) {\n  const body = source.body;\n  const bodyLength = body.length;\n  let end = position + 1;\n  let code = 0;\n  while (\n    end !== bodyLength &&\n    (code = charCodeAt.call(body, end)) !== null &&\n    (\n      code === 95 || // _\n      code >= 48 && code <= 57 || // 0-9\n      code >= 65 && code <= 90 || // A-Z\n      code >= 97 && code <= 122 // a-z\n    )\n  ) {\n    ++end;\n  }\n  return makeToken(\n    TokenKind.NAME,\n    position,\n    end,\n    slice.call(body, position, end)\n  );\n}\n"],"sourceRoot":"/home/iamchenxin/project/fork/graphql-js/src"}